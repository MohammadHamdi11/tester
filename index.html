<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QR Code Scanner</title>
<!-- PWA Meta Tags -->
<meta name="theme-color" content="#24325f">
<meta name="description" content="A QR code scanner application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="QR Scanner">
<!-- iOS icon links -->
<link rel="apple-touch-icon" href="icons/icon-152x152.png">
<!-- Manifest file link -->
<link rel="manifest" href="manifest.json">
<style>
:root {
--primary-color: #24325f;
--secondary-color: #951d1e;
--text-color: #000000;
--bg-color: #ffffff;
--card-bg: #ffffff;
--border-color: #3d3d3d;
--light-bg: #f9f9f9;
--hover-bg: #f5f5f5;
--disabled-bg: #cccccc;
--header-bg: #f0f0f0;
}
* {
box-sizing: border-box;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body {
margin: 0;
padding: 0;
background-color: var(--bg-color);
color: var(--text-color);
}
header {
background-color: var(--primary-color);
color: white;
text-align: center;
padding: 1rem;
position: sticky;
top: 0;
z-index: 100;
}
.container {
max-width: 1200px;
margin: 0 auto;
padding: 1rem;
}
/* Sign-in Styles */
.signin-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-color);
    z-index: 2000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.signin-container {
    background-color: var(--card-bg);
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    padding: 2rem;
    width: 90%;
    max-width: 400px;
}

.signin-container h2 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 1.5rem;
}

.signin-error {
    color: var(--secondary-color);
    text-align: center;
    margin-top: 1rem;
    min-height: 1.5em;
}
/* Card Styles */
.card {
background-color: var(--card-bg);
border-radius: 8px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
padding: 1rem;
margin-bottom: 1rem;
}
/* Button Styles */
.button {
background-color: var(--primary-color);
color: white;
border: none;
border-radius: 4px;
padding: 0.75rem 1rem;
cursor: pointer;
font-size: 1rem;
transition: background-color 0.3s;
}
.button:hover {
background-color: var(--secondary-color);
}
.button:disabled {
background-color: var(--disabled-bg);
cursor: not-allowed;
}
.button-secondary {
background-color: #f1f1f1;
color: var(--text-color);
border: 1px solid var(--border-color);
}
.button-secondary:hover {
background-color: #e1e1e1;
}
.button-small {
padding: 6px 12px;
font-size: 14px;
}
/* Tabs Styles */
.tabs {
display: flex;
border-bottom: 1px solid var(--border-color);
margin-bottom: 1rem;
overflow-x: auto; /* Enable horizontal scrolling */
white-space: nowrap; /* Prevent tab text from wrapping */
-webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
scrollbar-width: thin; /* For Firefox */
padding-bottom: 4px; /* Add some padding to account for scrollbar */
position: relative; /* For proper event handling */
cursor: grab; /* Show grab cursor to indicate scrollable */
}
.tabs.active-scroll {
cursor: grabbing; /* Change cursor when actively scrolling */
}
/* Hide scrollbar for Chrome, Safari and Opera */
.tabs::-webkit-scrollbar {
height: 4px;
}
/* Handle on hover */
.tabs::-webkit-scrollbar-thumb {
background: var(--border-color);
border-radius: 4px;
}
.tab {
padding: 0.75rem 1.5rem;
cursor: pointer;
border-bottom: 3px solid transparent;
flex-shrink: 0; /* Prevent tabs from shrinking */
user-select: none; /* Prevent text selection during drag */
}
.tab.active {
border-bottom: 3px solid var(--primary-color);
font-weight: bold;
}
.tab-content {
display: none;
}
.tab-content.active {
display: block;
}
/* Scanner Styles */
#video {
width: 100%;
background-color: #000;
border-radius: 8px;
}
.scanner-container {
position: relative;
min-height: 300px;
}
/* Table Styles */
.result-table {
width: 100%;
border-collapse: collapse;
margin-top: 1rem;
}
.result-table th, .result-table td {
border: 1px solid var(--border-color);
padding: 0.5rem;
text-align: left;
}
.result-table th {
background-color: #f1f1f1;
}
/* Modal Styles */
.modal {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
z-index: 1000;
}
.modal-content {
background-color: var(--card-bg);
margin: 15% auto;
padding: 20px;
border-radius: 8px;
width: 80%;
max-width: 500px;
}
.close {
float: right;
cursor: pointer;
font-size: 1.5rem;
}
/* Form Element Styles */
input[type="text"], select {
width: 100%;
padding: 0.75rem;
margin: 0.5rem 0;
border: 1px solid var(--border-color);
border-radius: 4px;
}
/* History Styles */
.history-item {
cursor: pointer;
}
.history-item:hover {
background-color: var(--hover-bg);
}
.session-details {
margin-top: 1rem;
}
.flex-between {
display: flex;
justify-content: space-between;
align-items: center;
flex-wrap: wrap;
}
.no-results {
text-align: center;
padding: 2rem;
color: #666;
}
.filter-controls {
margin-bottom: 1rem;
}
/* Checklist Styles */
.checklist-container {
margin-top: 1rem;
border: 1px solid #ddd;
border-radius: 8px;
background-color: var(--light-bg);
padding: 1rem;
max-height: 400px;
}
.checklist-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 1rem;
}
.search-input {
flex-grow: 1;
padding: 8px;
border: 1px solid #ccc;
border-radius: 4px;
margin-right: 1rem;
}
.checklist-area {
max-height: 300px;
overflow-y: auto;
border: 1px solid #ddd;
border-radius: 4px;
padding: 0.5rem;
background-color: white;
}
.student-list {
margin-bottom: 15px;
padding-left: 15px;
}
.checkbox-container {
display: flex;
align-items: center;
margin: 3px 0;
}
.checkbox-container input[type="checkbox"] {
margin-right: 8px;
}
.checklist-section-header {
font-weight: bold;
padding: 5px;
background-color: var(--header-bg);
border-radius: 4px;
margin-top: 8px;
position: sticky;
top: 0;
z-index: 1;
}
.student-group {
margin-bottom: 10px;
}
.group-header {
font-weight: bold;
padding: 5px;
background-color: var(--header-bg);
border-radius: 4px;
cursor: pointer;
display: flex;
justify-content: space-between;
}
.group-items {
padding-left: 15px;
margin-top: 5px;
}
.student-item {
display: flex;
align-items: center;
padding: 3px;
}
.student-item:hover {
background-color: var(--hover-bg);
}
.student-checkbox {
margin-right: 10px;
}
/* Form Group Styles */
.form-group {
margin-bottom: 1rem;
}
.form-group label {
display: block;
margin-bottom: 0.5rem;
font-weight: bold;
}
/* Mobile Styles */
@media (max-width: 768px) {
.button {
width: 100%;
margin-bottom: 0.5rem;
}
.flex-between {
flex-direction: column;
align-items: stretch;
}
.modal-content {
width: 95%;
margin: 10% auto;
}
}
</style>
</head>
<body>
<header>
<div id="signin-overlay" class="signin-overlay">
    <div class="signin-container">
        <h2>Sign In</h2>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" placeholder="Enter your email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" placeholder="Enter your password">
        </div>
        <button id="signin-button" class="button">Sign In</button>
        <p id="signin-error" class="signin-error"></p>
    </div>
</div>
<h1>Attendance Recorder App</h1>
</header>
<div class="container">
<div class="tabs">
<div class="tab active" data-tab="scanner">Scanner</div>
<div class="tab" data-tab="checklist">Selector</div>
<div class="tab" data-tab="history">History</div>
<div class="tab" data-tab="backup">Backup</div>
<div class="tab" data-tab="about">About</div>
<div class="tab" data-tab="contact-support">Contact Support</div>
</div>
</div>
<div id="scanner" class="tab-content active">
<div class="card">
<h2>QR Code Scanner</h2>
<div class="flex-between">
<div class="button-group">
<button id="startSessionBtn" class="button">Start New Session</button>
<button id="endSessionBtn" class="button" disabled>End Session</button>
<button id="addManualEntryBtn" class="button button-secondary" style="display: none;">Add Custom Entry</button>
</div>
<div id="sessionInfo" style="display: none;">
<p><strong>Location:</strong> <span id="currentLocation">-</span></p>
<p><strong>Started:</strong> <span id="currentDateTime">-</span></p>
</div>
</div>
<div class="scanner-container">
<div id="scanner-placeholder" style="text-align: center; padding: 2rem;">
<p>Click "Start New Session" to begin scanning QR codes.</p>
</div>
<video id="video" style="display: none;"></video>
</div>
<div class="scan-results">
<h3>Scanned QR Codes</h3>
<p id="noScansMessage">No QR codes scanned yet.</p>
<table id="resultTable" class="result-table" style="display: none;">
<thead>
<tr>
<th>ID</th>
<th>Content</th>
<th>Time</th>
</tr>
</thead>
<tbody id="resultBody"></tbody>
</table>
</div>
</div>
</div>
<div id="checklist" class="tab-content">
<div class="card">
<h2>Student Selector</h2>
<div class="flex-between">
<div class="button-group">
<button id="startChecklistSessionBtn" class="button">Start New Session</button>
<button id="endChecklistSessionBtn" class="button" disabled>End Session</button>
<button id="addCustomEntryBtn" class="button button-secondary" style="display: none;">Add Custom Entry</button>
</div>
<div id="checklistSessionInfo" style="display: none;">
<p><strong>Location:</strong> <span id="checklistLocation">-</span></p>
<p><strong>Started:</strong> <span id="checklistDateTime">-</span></p>
</div>
</div>
<div id="checklist-placeholder" style="text-align: center; padding: 2rem;">
<p>Click "Start New Session" to begin selecting students.</p>
</div>
<div class="checklist-container" style="display: none;">
<div class="checklist-header">
<input type="text" id="studentSearchInput" placeholder="Search for students..." class="search-input">
<button id="closeChecklistBtn" class="button button-small">Close</button>
</div>
<div id="studentsChecklist" class="checklist-area">
<!-- Students will be loaded here -->
</div>
</div>
<div class="selection-results">
<h3>Selected Students</h3>
<p id="noSelectionsMessage">No students selected yet.</p>
<table id="selectionTable" class="result-table" style="display: none;">
<thead>
<tr>
<th>ID</th>
<th>Content</th>
<th>Time</th>
</tr>
</thead>
<tbody id="selectionBody"></tbody>
</table>
</div>
</div>
</div>
<div id="history" class="tab-content">
<div class="card">
<h2>Scanning History</h2>
<div class="flex-between">
<div>
<button id="exportAllBtn" class="button">Export All History</button>
</div>
<div class="filter-controls">
<select id="sortBy">
<option value="date-desc">Date (Newest First)</option>
<option value="date-asc">Date (Oldest First)</option>
<option value="location">Location</option>
</select>
</div>
</div>
<div id="historyList">
<p class="no-results">No scanning sessions found.</p>
</div>
<div id="sessionDetails" class="session-details" style="display: none;">
<h3>Session Details</h3>
<div class="flex-between">
<div>
<p><strong>Location:</strong> <span id="detailLocation">-</span></p>
<p><strong>Date & Time:</strong> <span id="detailDateTime">-</span></p>
<p><strong>Scans:</strong> <span id="detailCount">-</span></p>
</div>
<div>
<button id="exportSessionBtn" class="button">Export Session</button>
<button id="closeDetailsBtn" class="button button-secondary">Close Details</button>
</div>
</div>
<table class="result-table">
<thead>
<tr>
<th>ID</th>
<th>Content</th>
<th>Time</th>
</tr>
</thead>
<tbody id="detailsBody"></tbody>
</table>
</div>
</div>
</div>
<div id="backup" class="tab-content">
<div class="card">
<h2>Backup Controls</h2>
<div class="backup-status">
<p><strong>Connection Status:</strong> <span id="connectionStatus">Checking...</span></p>
<p><strong>Last Backup:</strong> <span id="lastBackupTime">Never</span></p>
</div>
<div class="backup-controls">
<button id="backupBtn" class="button">Backup Now</button>
<p><small>Note: When online, backups automatically occur at app startup and when sessions end. If you need to manually backup the files, press the button above.</small></p>
</div>
</div>
</div>
<div id="about" class="tab-content">
<div class="card">
<h2>About This Application</h2>
<div class="about-section">
<h3>Function</h3>
<p>This application serves as both a QR Code Scanner and Student Selector for attendance tracking in educational settings.</p>
<h3>Purpose</h3>
<p>The application was developed to:</p>
<ul>
<li>Automate the attendance tracking process</li>
<li>Decrease unnecessary workload from staff</li>
<li>Provide reliable tracking and data management</li>
<li>Enable flexible student selection methods</li>
</ul>
<h3>Technical Details</h3>
<p>This is a Progressive Web Application (PWA) built using HTML, CSS, and JavaScript. This allows it to:</p>
<ul>
<li>Work offline once installed</li>
<li>Be installed on mobile devices</li>
<li>Provide a native app-like experience</li>
<li>Synchronize data when connectivity is restored</li>
</ul>
<h3>Features</h3>
<p><strong>QR Code Scanner:</strong> Scans student QR codes for quick attendance tracking</p>
<p><strong>Student Selector:</strong> Allows manual selection of students from organized lists</p>
<h3>Usage Instructions</h3>
<p>To use this application effectively:</p>
<h4>Scanner Mode:</h4>
<ol>
<li>Start a new scanning session and specify the location</li>
<li>Scan student QR codes or add entries manually</li>
<li>End the session when complete</li>
</ol>
<h4>Selector Mode:</h4>
<ol>
<li>Start a new session and specify the location</li>
<li>Filter students by year/group and select from the list</li>
<li>Use the search function to quickly find specific students</li>
<li>Add custom entries for special cases</li>
<li>End the session when complete</li>
</ol>
<p><strong>For Both Modes:</strong></p>
<ul>
<li>Review past sessions in the History tab</li>
<li>Backup your data regularly from the Backup tab</li>
<li>Export data as needed for record keeping</li>
</ul>
<h3>Development Team</h3>
<p>This application was developed by a medical student at Faculty of Medicine, Ain Shams University as part of ongoing efforts to integrate technological solutions into educational processes at the university.</p>
</div>
</div>
</div>
<div id="contact-support" class="tab-content">
<div class="card">
<h2>Contact Support</h2>
<div class="about-section">
<h3>Get Help</h3>
<p>If you have any questions, suggestions, or encounter issues with the application, please submit your inquiry through our support form:</p>
<a href="https://docs.google.com/forms/d/e/1FAIpQLSfOt-UrLB_rBF6NdpPHG2iTaB8B5AcZIfkkQfOTslpsAULRBg/viewform?usp=header" target="_blank" class="button">Open Support Form</a>
</div>
<div class="form-group">
<h3>Response Time</h3>
<p>We typically respond to all inquiries within 24-48 hours.</p>
</div>
</div>
</div>
</div>
<!-- Modal for Manual Entry -->
<div id="manualEntryModal" class="modal">
<div class="modal-content">
<span class="close" id="closeManualEntryBtn">&times;</span>
<h2>Enter Student ID Manually</h2>
<div class="form-group">
<p>Please enter the student ID:</p>
<input type="text" id="manualIdInput" placeholder="e.g., S12345678">
</div>
<button id="confirmManualEntryBtn" class="button">Add Entry</button>
</div>
</div>
<!-- Modal for Starting Session -->
<div id="sessionModal" class="modal">
<div class="modal-content">
<span class="close" id="closeSessionBtn">&times;</span>
<h2>Start New Session</h2>
<div class="form-group">
<p>Enter a location for this scanning session:</p>
<input type="text" id="locationInput" placeholder="e.g., Morgue, Histology Lab, Biochemistry Lecture Hall">
</div>
<button id="confirmSessionBtn" class="button">Start Now</button>
</div>
</div>
<!-- Modal for Custom Entry -->
<div id="customEntryModal" class="modal">
<div class="modal-content">
<span class="close" id="closeCustomEntryBtn">&times;</span>
<h2>Add Custom Student ID</h2>
<div class="form-group">
<label for="customIdInput">Student ID:</label>
<input type="text" id="customIdInput" placeholder="Enter student ID">
</div>
<button id="confirmCustomEntryBtn" class="button">Add Student</button>
</div>
</div>
<!-- Checklist Session Modal -->
<div id="checklistModal" class="modal">
<div class="modal-content">
<span class="close" id="closeChecklistModalBtn">&times;</span>
<h2>Start New Session</h2>
<div class="form-group">
<p>Enter a location for this scanning session:</p>
<input type="text" id="checklistLocationInput" placeholder="e.g., Morgue, Histology Lab, Biochemistry Lecture Hall">
</div>
<div class="modal-actions">
<button id="confirmChecklistBtn" class="button">Start Session</button>
</div>
</div>
</div>
<!-- Script for QR Code Scanning -->
<script src="https://unpkg.com/@zxing/library@latest"></script>
<!-- Script for Excel Export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
//========================================================================================================== SIGN IN AND AUTHENTICATION ========//
// Authentication variables and functions
const signinOverlay = document.getElementById('signin-overlay');
const signinButton = document.getElementById('signin-button');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const signinError = document.getElementById('signin-error');
const AUTH_STATUS_KEY = 'qrScannerAuthStatus';

// Check if user is already authenticated
function checkAuthentication() {
    const authStatus = localStorage.getItem(AUTH_STATUS_KEY);
    if (authStatus === 'authenticated') {
        signinOverlay.style.display = 'none';
    } else {
        signinOverlay.style.display = 'flex';
        loadUserCredentials();
    }
}

// Load user credentials from JSON file
let userCredentials = [];
async function loadUserCredentials() {
    try {
        const response = await fetch('usercredentials.json');
        if (!response.ok) {
            throw new Error('Failed to load user credentials');
        }
        userCredentials = await response.json();
    } catch (error) {
        console.error('Error loading credentials:', error);
        signinError.textContent = 'Could not load authentication data. Please try again later.';
    }
}

// Authenticate user
function authenticateUser(email, password) {
    if (!userCredentials || userCredentials.length === 0) {
        signinError.textContent = 'Authentication system is not available';
        return false;
    }

    const user = userCredentials.find(user => 
        user.email.toLowerCase() === email.toLowerCase() && 
        user.password === password
    );

    if (user) {
        localStorage.setItem(AUTH_STATUS_KEY, 'authenticated');
        signinOverlay.style.display = 'none';
        return true;
    } else {
        signinError.textContent = 'Invalid email or password';
        return false;
    }
}

// Event listener for sign-in button
signinButton.addEventListener('click', () => {
    const email = emailInput.value.trim();
    const password = passwordInput.value;
    
    if (!email) {
        signinError.textContent = 'Please enter your email';
        return;
    }
    
    if (!password) {
        signinError.textContent = 'Please enter your password';
        return;
    }
    
    authenticateUser(email, password);
});

// Clear error message when user starts typing
emailInput.addEventListener('input', () => {
    signinError.textContent = '';
});

passwordInput.addEventListener('input', () => {
    signinError.textContent = '';
});

// Check authentication status when the page loads
document.addEventListener('DOMContentLoaded', checkAuthentication);
//========================================================================================================== ELEMENTS ========//
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');
const startSessionBtn = document.getElementById('startSessionBtn');
const sessionModal = document.getElementById('sessionModal');
const closeSessionBtn = document.getElementById('closeSessionBtn');
const confirmSessionBtn = document.getElementById('confirmSessionBtn');
const locationInput = document.getElementById('locationInput');
const currentLocation = document.getElementById('currentLocation');
const currentDateTime = document.getElementById('currentDateTime');
const sessionInfo = document.getElementById('sessionInfo');
const video = document.getElementById('video');
const scannerPlaceholder = document.getElementById('scanner-placeholder');
const resultTable = document.getElementById('resultTable');
const resultBody = document.getElementById('resultBody');
const noScansMessage = document.getElementById('noScansMessage');
const exportAllBtn = document.getElementById('exportAllBtn');
const historyList = document.getElementById('historyList');
const sessionDetails = document.getElementById('sessionDetails');
const detailLocation = document.getElementById('detailLocation');
const detailDateTime = document.getElementById('detailDateTime');
const detailCount = document.getElementById('detailCount');
const detailsBody = document.getElementById('detailsBody');
const exportSessionBtn = document.getElementById('exportSessionBtn');
const closeDetailsBtn = document.getElementById('closeDetailsBtn');
const sortBy = document.getElementById('sortBy');
const backupBtn = document.getElementById('backupBtn');
const lastBackupTime = document.getElementById('lastBackupTime');
const connectionStatus = document.getElementById('connectionStatus');
const githubTokenInput = document.getElementById('githubTokenInput');
const saveTokenBtn = document.getElementById('saveTokenBtn');
const tokenStatusMessage = document.getElementById('tokenStatusMessage');
const autoBackupStatus = document.getElementById('autoBackupStatus');
const manualEntryModal = document.getElementById('manualEntryModal');
const closeManualEntryBtn = document.getElementById('closeManualEntryBtn');
const manualIdInput = document.getElementById('manualIdInput');
const confirmManualEntryBtn = document.getElementById('confirmManualEntryBtn');
let successSound = null;
let activeSession = null;
let canvasElement = document.createElement('canvas');
let canvas = canvasElement.getContext('2d');
let scanning = false;
let videoStream = null;
let sessions = [];
let activeSessionId = null;
let lastScannedCodes = new Set(); // For avoiding duplicate scans in quick succession
let jsQRLoaded = false;
let autoSaveInterval = null;
let backupInProgress = false;
let lastBackupSessions = 0; // Track number of sessions at last backup
// Constants for auto-save functionality
const AUTO_SAVE_DELAY = 3000; // 3 seconds
const ACTIVE_SESSION_STORAGE_KEY = 'qrScannerActiveSession';
const COMPLETED_SESSIONS_STORAGE_KEY = 'qrScannerSessions';
const TEMP_SESSION_INDEX_KEY = 'qrScannerTempSessionIndex';
// GitHub backup constants
const GITHUB_TOKEN_KEY = 'qrScannerGithubToken';
const LAST_BACKUP_TIME_KEY = 'qrScannerLastBackupTime';
const LAST_BACKUP_SESSIONS_KEY = 'qrScannerLastBackupSessions';
const DEFAULT_GITHUB_OWNER = 'MohammadHamdi11';
const DEFAULT_GITHUB_REPO = 'MedASUAttendanceManagementSystem';
const DEFAULT_GITHUB_PATH = 'backups';
const DEFAULT_GITHUB_BRANCH = 'main';
const AUTO_BACKUP_ENABLED_KEY = 'qrScannerAutoBackupEnabled';
// GitHub token parts (to avoid detection)
const GITHUB_TOKEN_PREFIX = 'github_pat_';
const GITHUB_TOKEN_SUFFIX = '11BREVRNQ0XVpxHicj3xsl_vAfICFbNYso7tpxkuw9yZqcOG4FHzacfgkpOjBJE51HR3WGTNJTaUIfxSWg';
let batchModeActive = true; // Always enabled as requested
let batchBuffer = new Set(); // Store unique QR codes during batch scanning
let processingBatch = false; // Flag to prevent concurrent batch processing
let batchProcessingInterval = null; // Interval for batch processing
//========================================================================================================== GITHUB BACKUP FUNCTIONS ========//
// Check internet connection status
function updateConnectionStatus() {
if (navigator.onLine) {
connectionStatus.textContent = 'Online';
connectionStatus.style.color = '#4caf50'; // Green
connectionStatus.style.fontWeight = 'bold';
// Update auto-backup status display if element exists
if (autoBackupStatus) {
const autoBackupEnabled = localStorage.getItem(AUTO_BACKUP_ENABLED_KEY) !== 'false';
autoBackupStatus.textContent = autoBackupEnabled ? 'Enabled' : 'Disabled';
autoBackupStatus.style.color = autoBackupEnabled ? '#4caf50' : '#f44336';
}
} else {
connectionStatus.textContent = 'Offline';
connectionStatus.style.color = '#f44336'; // Red
connectionStatus.style.fontWeight = 'bold';
if (autoBackupStatus) {
autoBackupStatus.textContent = 'Unavailable (Offline)';
autoBackupStatus.style.color = '#f44336';
}
}
}
// Get GitHub token by combining prefix and suffix
function getGitHubToken() {
// First try to get from localStorage in case user manually set it
const storedToken = localStorage.getItem(GITHUB_TOKEN_KEY);
if (storedToken && storedToken.trim() !== '') {
console.log('Using token from localStorage');
return storedToken.trim();
}
// If no stored token, use the hardcoded one
console.log('Using hardcoded token');
const combinedToken = (GITHUB_TOKEN_PREFIX + GITHUB_TOKEN_SUFFIX).trim();
// Debug log token length without revealing actual token
console.log(`Token length: ${combinedToken.length}`);
// Basic validation check
if (combinedToken.length < 30) {
console.warn('Warning: Token appears to be too short or malformed');
}
return combinedToken;
}
// Save GitHub token to local storage
async function saveGitHubToken() {
const token = githubTokenInput.value.trim();
if (token) {
try {
tokenStatusMessage.textContent = 'Validating token...';
tokenStatusMessage.style.color = '#ff9800'; // Orange for in-progress
// Validate token before saving
const isValid = await validateGitHubToken(token);
if (isValid) {
localStorage.setItem(GITHUB_TOKEN_KEY, token);
tokenStatusMessage.textContent = 'Token validated and saved successfully!';
tokenStatusMessage.style.color = '#4caf50';
// Enable auto-backup by default when token is saved
localStorage.setItem(AUTO_BACKUP_ENABLED_KEY, 'true');
updateConnectionStatus(); // Update status display
setTimeout(() => {
tokenStatusMessage.textContent = '';
}, 3000);
} else {
tokenStatusMessage.textContent = 'Invalid token. Please check your token and permissions.';
tokenStatusMessage.style.color = '#f44336';
}
} catch (error) {
console.error('Error saving GitHub token:', error);
tokenStatusMessage.textContent = 'Error validating token: ' + error.message;
tokenStatusMessage.style.color = '#f44336';
}
} else {
tokenStatusMessage.textContent = 'Please enter a valid token.';
tokenStatusMessage.style.color = '#f44336';
}
}
// Load GitHub token from local storage or use hardcoded one
function loadGitHubToken() {
try {
const token = localStorage.getItem(GITHUB_TOKEN_KEY);
if (token) {
githubTokenInput.value = token;
return token;
} else {
// If no token in localStorage, use the hardcoded one
const hardcodedToken = GITHUB_TOKEN_PREFIX + GITHUB_TOKEN_SUFFIX;
// We don't display the hardcoded token in the input field for security
return hardcodedToken;
}
} catch (error) {
console.error('Error loading GitHub token:', error);
// Fall back to hardcoded token on error
return GITHUB_TOKEN_PREFIX + GITHUB_TOKEN_SUFFIX;
}
}
// Update last backup time display
function updateLastBackupTimeDisplay() {
try {
const lastBackup = localStorage.getItem(LAST_BACKUP_TIME_KEY);
if (lastBackup) {
const backupDate = new Date(lastBackup);
// Format date as dd/mm/yyyy
const day = String(backupDate.getDate()).padStart(2, '0');
const month = String(backupDate.getMonth() + 1).padStart(2, '0');
const year = backupDate.getFullYear();
// Format time
const hours = String(backupDate.getHours()).padStart(2, '0');
const minutes = String(backupDate.getMinutes()).padStart(2, '0');
const seconds = String(backupDate.getSeconds()).padStart(2, '0');
// Combine into dd/mm/yyyy HH:MM:SS format
const formattedTime = `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
lastBackupTime.textContent = formattedTime;
} else {
lastBackupTime.textContent = 'Never';
}
} catch (error) {
console.error('Error loading last backup time:', error);
lastBackupTime.textContent = 'Error';
}
}
// Convert data to Excel workbook
function prepareDataForBackup() {
// Create a new workbook
const workbook = XLSX.utils.book_new();
// Counter for unique sheet names
let sheetCounter = {};
// For each session, create a separate sheet with proper format
sessions.forEach(session => {
const data = [
['Number', 'Student ID', 'Location', 'Log Date', 'Log Time']
];
// Add each scan in the proper format
session.scans.forEach(scan => {
const scanDate = new Date(scan.time);
data.push([
scan.id,                // Row number
scan.content,           // QR code content (Student ID)
session.location,       // Location
formatDate(scanDate),   // Date
formatTime(scanDate)    // Time
]);
});
// Only create sheet if session has scans
if (data.length > 1) {
const ws = XLSX.utils.aoa_to_sheet(data);
// Create unique sheet name based on location
let baseSheetName = session.location.substring(0, 25).replace(/[^a-z0-9]/gi, '_');
if (baseSheetName.length === 0) baseSheetName = "Session";
// Ensure uniqueness
if (sheetCounter[baseSheetName]) {
sheetCounter[baseSheetName]++;
baseSheetName = baseSheetName + "_" + sheetCounter[baseSheetName];
} else {
sheetCounter[baseSheetName] = 1;
}
// Excel sheet names cannot exceed 31 characters
const sheetName = baseSheetName.substring(0, 31);
try {
XLSX.utils.book_append_sheet(workbook, ws, sheetName);
} catch (e) {
console.error("Error adding sheet:", e);
// If there's an error with this sheet, try with a generic name
XLSX.utils.book_append_sheet(workbook, ws, "Session_" + Math.random().toString(36).substring(2, 7));
}
}
});
return workbook;
}
// Check if backup is needed
function isBackupNeeded() {
// Check if we have more sessions than last time we backed up
const savedLastBackupSessions = parseInt(localStorage.getItem(LAST_BACKUP_SESSIONS_KEY) || '0');
return sessions.length > savedLastBackupSessions;
}
// Try to automatically backup data if conditions are met
async function tryAutoBackup() {
// Don't run if already in progress, offline, or disabled
if (backupInProgress || !navigator.onLine) {
return false;
}
const autoBackupEnabled = localStorage.getItem(AUTO_BACKUP_ENABLED_KEY) !== 'false';
if (!autoBackupEnabled) {
console.log('Auto-backup is disabled');
return false;
}
// Get token from combined hardcoded values or localStorage
const token = getGitHubToken();
if (!token) {
console.log('GitHub token not found, auto-backup skipped');
return false;
}
// Check if there's anything new to backup
if (!isBackupNeeded()) {
console.log('No new data to backup');
return false;
}
console.log('Starting automatic backup...');
try {
// Create Excel workbook
const workbook = prepareDataForBackup();
// Create filename with date
const fileName = `qr_scanner_backup_${formatDateTimeForFile(new Date())}.xlsx`;
// Perform the backup
await backupToGitHub(true, fileName, workbook);
console.log('Auto-backup completed successfully');
return true;
} catch (error) {
console.error('Auto-backup failed:', error);
return false;
}
}
// Backup to GitHub
async function backupToGitHub(isAutoBackup = false, customFileName = null, workbook = null) {
if (!navigator.onLine) {
if (!isAutoBackup) {
alert('Cannot backup: You are offline.');
}
return;
}
// Get token from combined hardcoded values or localStorage
const token = getGitHubToken();
if (!token) {
if (!isAutoBackup) {
alert('No GitHub token available.');
}
return;
}
// Check token format
checkTokenFormat();
try {
backupInProgress = true;
if (!isAutoBackup && backupBtn) {
backupBtn.disabled = true;
backupBtn.textContent = 'Backing up...';
}
// Create filename with date if not provided
const fileName = customFileName || `qr_scanner_backup_${formatDateTimeForFile(new Date())}.xlsx`;
// Create workbook if not provided
if (!workbook) {
workbook = prepareDataForBackup();
}
// Convert workbook to base64
const excelData = XLSX.write(workbook, { bookType: 'xlsx', type: 'base64' });
// Repository information - ensure consistent string handling
const repoOwner = DEFAULT_GITHUB_OWNER.toString().trim();
const repoName = DEFAULT_GITHUB_REPO.toString().trim();
// Normalize path by removing leading/trailing slashes
const filePath = DEFAULT_GITHUB_PATH.toString().trim().replace(/^\/|\/$/g, '');
const branchName = DEFAULT_GITHUB_BRANCH.toString().trim();
// Log values for debugging on mobile
console.log(`Repository owner: ${repoOwner}`);
console.log(`Repository name: ${repoName}`);
console.log(`File path: ${filePath}`);
console.log(`Branch name: ${branchName}`);
console.log(`File name: ${fileName}`);
// First, check if the repository exists and is accessible
const repoCheckUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}`;
console.log(`Checking repository: ${repoCheckUrl}`);
const repoCheckResponse = await fetch(repoCheckUrl, {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (!repoCheckResponse.ok) {
const repoErrorData = await repoCheckResponse.json();
throw new Error(`Repository check failed: ${repoErrorData.message} (HTTP ${repoCheckResponse.status})`);
}
// Consistently build the path components
const directoryPath = filePath ? `${filePath}` : '';
// Now check if the directory path exists
let pathCheckUrl;
if (directoryPath) {
pathCheckUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/contents/${encodeURIComponent(directoryPath)}?ref=${encodeURIComponent(branchName)}`;
console.log(`Checking directory path: ${pathCheckUrl}`);
const pathCheckResponse = await fetch(pathCheckUrl, {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (!pathCheckResponse.ok) {
console.log(`Directory path ${directoryPath} may not exist: ${pathCheckResponse.status}`);
// For directories that don't exist, we need to handle this case
// For now, we'll continue and let the PUT request handle it
}
}
// Construct the complete file path
const filePathComponent = directoryPath ? `${directoryPath}/` : '';
const fullFilePath = `${filePathComponent}${fileName}`;
console.log(`Full file path: ${fullFilePath}`);
// Check for existing file to get SHA
let sha = null;
const fileCheckUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/contents/${encodeURIComponent(fullFilePath)}?ref=${encodeURIComponent(branchName)}`;
console.log(`Checking file: ${fileCheckUrl}`);
try {
const checkResponse = await fetch(fileCheckUrl, {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (checkResponse.ok) {
const fileInfo = await checkResponse.json();
sha = fileInfo.sha;
console.log(`File exists, SHA: ${sha}`);
} else {
console.log(`File does not exist (status ${checkResponse.status}). Creating new file.`);
}
} catch (error) {
console.log('Error checking file existence:', error);
}
// Prepare the request body
const requestBody = {
message: `Backup QR Scanner data - ${new Date().toLocaleString()}`,
content: excelData,
branch: branchName
};
if (sha) {
requestBody.sha = sha;
}
// Now create or update the file
const putUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/contents/${encodeURIComponent(fullFilePath)}`;
console.log(`Sending PUT request to: ${putUrl}`);
const response = await fetch(putUrl, {
method: 'PUT',
headers: {
'Authorization': `token ${token}`,
'Content-Type': 'application/json',
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
},
body: JSON.stringify(requestBody)
});
if (response.ok) {
// Update last backup time
const now = new Date().toISOString();
localStorage.setItem(LAST_BACKUP_TIME_KEY, now);
localStorage.setItem(LAST_BACKUP_SESSIONS_KEY, sessions.length.toString());
updateLastBackupTimeDisplay();
if (!isAutoBackup) {
alert('Backup completed successfully!');
}
} else {
const errorData = await response.json();
const status = response.status;
throw new Error(`GitHub API error (HTTP ${status}): ${errorData.message}. Details: ${JSON.stringify(errorData)}`);
}
} catch (error) {
console.error('GitHub backup error:', error);
// More informative error message
const errorMessage = `Backup failed: ${error.message}. 
Please check: 
1. Your GitHub token has correct permissions
2. The repository exists and is accessible
3. You have write access to the repository`;
if (!isAutoBackup) {
alert(errorMessage);
}
} finally {
backupInProgress = false;
if (!isAutoBackup && backupBtn) {
backupBtn.disabled = false;
backupBtn.textContent = 'Backup Now';
}
}
}
// Export Excel file to GitHub
async function exportExcelToGitHub(fileName, workbook) {
return new Promise(async (resolve, reject) => {
if (!navigator.onLine) {
console.log('Cannot backup Excel: You are offline.');
reject(new Error('You are offline'));
return;
}
// Get token from combined hardcoded values or localStorage
const token = getGitHubToken();
if (!token) {
console.log('GitHub token not available, skipping Excel backup.');
reject(new Error('No GitHub token available'));
return;
}
try {
// Convert workbook to base64
const excelData = XLSX.write(workbook, { bookType: 'xlsx', type: 'base64' });
// Repository information - ensure consistent string handling
const repoOwner = DEFAULT_GITHUB_OWNER.toString().trim();
const repoName = DEFAULT_GITHUB_REPO.toString().trim();
// Normalize path by removing leading/trailing slashes
const filePath = DEFAULT_GITHUB_PATH.toString().trim().replace(/^\/|\/$/g, '');
const branchName = DEFAULT_GITHUB_BRANCH.toString().trim();
// Enhanced logging for mobile debugging
console.log(`Export Excel to GitHub: Repository: ${repoOwner}/${repoName}`);
console.log(`File path: ${filePath}`);
console.log(`File name: ${fileName}`);
console.log(`Branch: ${branchName}`);
// Consistently build the path components
const filePathComponent = filePath ? `${filePath}/` : '';
const fullFilePath = `${filePathComponent}${fileName}`;
console.log(`Full file path: ${fullFilePath}`);
// First, try to get the SHA of the file if it exists
let sha = null;
const fileCheckUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/contents/${encodeURIComponent(fullFilePath)}?ref=${encodeURIComponent(branchName)}`;
console.log(`Checking file: ${fileCheckUrl}`);
try {
const checkResponse = await fetch(fileCheckUrl, {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (checkResponse.ok) {
const fileInfo = await checkResponse.json();
sha = fileInfo.sha;
console.log(`File exists, SHA: ${sha}`);
} else {
console.log(`File does not exist (status ${checkResponse.status}). Creating new file.`);
}
} catch (error) {
console.log('Error checking file existence:', error);
}
// Now create or update the file
const requestBody = {
message: `Export Excel data - ${new Date().toLocaleString()}`,
content: excelData,
branch: branchName
};
if (sha) {
requestBody.sha = sha;
}
const putUrl = `https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}/contents/${encodeURIComponent(fullFilePath)}`;
console.log(`Sending PUT request to: ${putUrl}`);
const response = await fetch(putUrl, {
method: 'PUT',
headers: {
'Authorization': `token ${token}`,
'Content-Type': 'application/json',
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
},
body: JSON.stringify(requestBody)
});
if (response.ok) {
console.log('Excel file uploaded to GitHub successfully');
// Update last backup time and session count as this is now our main backup format
const now = new Date().toISOString();
localStorage.setItem(LAST_BACKUP_TIME_KEY, now);
localStorage.setItem(LAST_BACKUP_SESSIONS_KEY, sessions.length.toString());
updateLastBackupTimeDisplay();
resolve();
} else {
const errorData = await response.json();
const status = response.status;
console.error(`GitHub API error (HTTP ${status}): ${errorData.message}`);
reject(new Error(`GitHub API error (HTTP ${status}): ${errorData.message}`));
}
} catch (error) {
console.error('GitHub Excel export error:', error);
reject(error);
}
});
}
// Validate GitHub token by checking access to the repository
async function validateGitHubToken(token) {
if (!token) return false;
try {
const repoOwner = DEFAULT_GITHUB_OWNER.toString().trim();
const repoName = DEFAULT_GITHUB_REPO.toString().trim();
const response = await fetch(`https://api.github.com/repos/${encodeURIComponent(repoOwner)}/${encodeURIComponent(repoName)}`, {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
return response.ok;
} catch (error) {
console.error('Error validating GitHub token:', error);
return false;
}
}
// Add a function to test GitHub API connectivity
async function testGitHubApiConnection() {
const token = getGitHubToken();
if (!token) {
alert('No GitHub token available.');
return;
}
try {
// Start with simple API request
const response = await fetch('https://api.github.com', {
method: 'GET',
headers: {
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (response.ok) {
console.log('Basic GitHub API connectivity successful');
// Now test with authentication
const authResponse = await fetch('https://api.github.com/user', {
method: 'GET',
headers: {
'Authorization': `token ${token}`,
'Accept': 'application/vnd.github.v3+json',
'User-Agent': 'QRScannerApp/MobileClient'
}
});
if (authResponse.ok) {
const userData = await authResponse.json();
console.log('Authenticated as:', userData.login);
alert(`GitHub API test successful. Authenticated as: ${userData.login}`);
} else {
const errorData = await authResponse.json();
console.error('Authentication test failed:', errorData);
alert(`Authentication test failed: ${errorData.message}`);
}
} else {
alert(`GitHub API connectivity test failed: ${response.status}`);
}
} catch (error) {
console.error('GitHub API test error:', error);
alert(`GitHub API test error: ${error.message}`);
}
}
// Diagnostic function to check token format without revealing full token
function checkTokenFormat() {
const token = getGitHubToken();
if (!token) {
console.error('No token available');
return false;
}
// Check basic format without revealing token
const tokenStart = token.substring(0, 4);
const tokenEnd = token.substring(token.length - 4);
const tokenLength = token.length;
console.log(`Token format check: 
- Length: ${tokenLength}
- Starts with: ${tokenStart}...
- Ends with: ...${tokenEnd}
- Contains spaces: ${token.includes(' ')}
- Contains newlines: ${token.includes('\n')}
- Format appears to be personal access token: ${token.startsWith('ghp_') || token.startsWith('github_pat_')}
`);
return true;
}
//========================================================================================================== INITIALIZATION ========//
// Check if jsQR is already loaded from the local file
document.addEventListener('DOMContentLoaded', function() {
preloadSuccessSound();
console.log("DOM fully loaded");
loadSessionsFromStorage();
checkForRecoverableSession();
updateHistoryView();
// Initialize backup tab
updateConnectionStatus();
loadGitHubToken();
updateLastBackupTimeDisplay();
// Setup manual entry functionality
setupManualEntryButton();
// Setup button event listeners
setupButtonEventListeners();
// Enable auto-backup by default
if (localStorage.getItem(AUTO_BACKUP_ENABLED_KEY) === null) {
localStorage.setItem(AUTO_BACKUP_ENABLED_KEY, 'true');
}
// Setup online/offline event listeners
window.addEventListener('online', () => {
updateConnectionStatus();
// Try auto-backup when connection is restored
tryAutoBackup();
});
window.addEventListener('offline', updateConnectionStatus);
// Check if jsQR is already defined (from the script tag in HTML)
if (typeof jsQR === 'function') {
console.log("jsQR is already loaded from local file");
jsQRLoaded = true;
} else {
console.log("jsQR not detected, will attempt to load");
loadJsQR()
.then(() => console.log("jsQR library loaded and ready"))
.catch(error => {
console.error("Error loading jsQR:", error);
alert("Failed to load QR code scanning library. Please check your files and try again.");
});
}
// Load last backup session count
lastBackupSessions = parseInt(localStorage.getItem(LAST_BACKUP_SESSIONS_KEY) || '0');
// Try auto-backup if online and there are new sessions
if (navigator.onLine) {
// Use setTimeout to ensure the app is fully loaded first
setTimeout(() => {
tryAutoBackup().then(success => {
if (success) {
console.log("Initial auto-backup completed");
}
});
}, 2000);
}
// Add beforeunload event listener to prevent accidental closing during active session
// This only handles scanner session - checklist module handles its own separately
window.addEventListener('beforeunload', handleBeforeUnload);
// Initialize the checklist module if the elements exist
if (document.getElementById('startChecklistSessionBtn')) {
initializeChecklistModule();
}
});
//================================================================================================================================
// Load jsQR from local file
function loadJsQR() {
return new Promise((resolve, reject) => {
// Check if jsQR is already loaded
if (typeof jsQR === 'function') {
jsQRLoaded = true;
resolve(true);
return;
}
// Create a new script element to load the local file
const script = document.createElement('script');
script.src = 'jsQR.min.js'; // Local file path
// Set event handlers
script.onload = () => {
console.log("jsQR loaded successfully from local file");
jsQRLoaded = true;
resolve(true);
};
script.onerror = (error) => {
console.error("Failed to load local jsQR:", error);
reject(error);
};
// Add the script to the document
document.head.appendChild(script);
});
}
//========================================================================================================== SERVICE WORKER REGISTRATION FOR PWA ========//
if ('serviceWorker' in navigator) {
window.addEventListener('load', () => {
navigator.serviceWorker.register('./sw.js')
.then(registration => {
console.log('ServiceWorker registration successful with scope: ', registration.scope);
})
.catch(err => {
console.log('ServiceWorker registration failed: ', err);
});
});
}
//========================================================================================================== MANUAL ENTRY FUNCTIONS ========//
// Setup manual entry button
function setupManualEntryButton() {
// Get the button element
const addManualEntryBtn = document.getElementById('addManualEntryBtn');
// Add click event listener
addManualEntryBtn.addEventListener('click', () => {
// Show the manual entry modal
manualEntryModal.style.display = 'block';
// Focus on the input field
manualIdInput.focus();
// Clear previous inputs
manualIdInput.value = '';
manualInfoInput.value = '';
});
// Add close button event listener
if (closeManualEntryBtn) {
closeManualEntryBtn.addEventListener('click', () => {
manualEntryModal.style.display = 'none';
});
}
// Add confirm button event listener
if (confirmManualEntryBtn) {
confirmManualEntryBtn.addEventListener('click', processManualEntry);
}
// Also allow pressing Enter to confirm
manualIdInput.addEventListener('keyup', (event) => {
if (event.key === 'Enter') {
processManualEntry();
}
});
}
// Process manual entry
function processManualEntry() {
const studentId = manualIdInput.value.trim();
if (!studentId) {
alert('Please enter a Student ID');
return;
}
// Use studentId directly without additional info
processScannedCode(studentId, true);
manualEntryModal.style.display = 'none';
updateScanStatus(`✅ Manual entry added: ${studentId.substring(0, 20)}${studentId.length > 20 ? '...' : ''}`);
addScanLogEntry(`Manual entry: ${studentId.substring(0, 15)}${studentId.length > 15 ? '...' : ''}`, 'success');
}
// Process scanned QR code (modified to handle manual entries)
function processScannedCode(data, isManual = false) {
// Additional validation to ensure we're not adding empty codes
if (!data || data.trim() === '') {
console.error("Attempted to process empty QR code data");
updateScanStatus('Error: Empty QR code data');
addScanLogEntry('Empty QR code data - not saved', 'error');
return;
}
const now = new Date();
const scan = {
id: activeSession.scans.length + 1,
content: data,
time: now.toISOString(),
formattedTime: formatTime(now),
isManual: isManual  // Flag to indicate if this was a manual entry
};
// Add to active session
activeSession.scans.push(scan);
// Update UI
if (activeSession.scans.length === 1) {
noScansMessage.style.display = 'none';
resultTable.style.display = 'table';
}
const row = document.createElement('tr');
// Add a class to the row if it's a manual entry
if (isManual) {
row.className = 'manual-entry';
}
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}${isManual ? ' <span class="badge">Manual</span>' : ''}</td>
<td>${scan.formattedTime}</td>
`;
resultBody.appendChild(row);
// Find the session in the sessions array and update it
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex] = {...activeSession};
}
// Save both active session and completed sessions
saveActiveSession();
saveSessionsToStorage();
// For manual entries, we don't need to play sound
if (!isManual) {
playSuccessSound();
}
}
//========================================================================================================== UI NAVIGATION & EVENT HANDLERS ========//
// Tab scrolling functionality
function setupTabScrolling() {
const tabsContainer = document.querySelector('.tabs');
if (!tabsContainer) return;
// Variables for tracking touch/mouse events
let isDown = false;
let startX;
let scrollLeft;
// Mouse events for desktop
tabsContainer.addEventListener('mousedown', (e) => {
isDown = true;
tabsContainer.classList.add('active-scroll');
startX = e.pageX - tabsContainer.offsetLeft;
scrollLeft = tabsContainer.scrollLeft;
});
tabsContainer.addEventListener('mouseleave', () => {
isDown = false;
tabsContainer.classList.remove('active-scroll');
});
tabsContainer.addEventListener('mouseup', () => {
isDown = false;
tabsContainer.classList.remove('active-scroll');
});
tabsContainer.addEventListener('mousemove', (e) => {
if (!isDown) return;
e.preventDefault();
const x = e.pageX - tabsContainer.offsetLeft;
const walk = (x - startX) * 2; // Scroll speed multiplier
tabsContainer.scrollLeft = scrollLeft - walk;
});
// Touch events for mobile
tabsContainer.addEventListener('touchstart', (e) => {
isDown = true;
tabsContainer.classList.add('active-scroll');
startX = e.touches[0].pageX - tabsContainer.offsetLeft;
scrollLeft = tabsContainer.scrollLeft;
});
tabsContainer.addEventListener('touchend', () => {
isDown = false;
tabsContainer.classList.remove('active-scroll');
});
tabsContainer.addEventListener('touchmove', (e) => {
if (!isDown) return;
const x = e.touches[0].pageX - tabsContainer.offsetLeft;
const walk = (x - startX) * 2;
tabsContainer.scrollLeft = scrollLeft - walk;
});
// Add horizontal wheel scrolling support
tabsContainer.addEventListener('wheel', (e) => {
if (e.deltaY !== 0) {
e.preventDefault();
tabsContainer.scrollLeft += e.deltaY;
}
}, { passive: false });
console.log("Tab scrolling functionality initialized");
}
// Set up button event listeners
function setupButtonEventListeners() {
// Start Session Button
startSessionBtn.addEventListener('click', startSessionBtnHandler);
// End Session Button - Make sure this is properly defined in DOM Elements
const endSessionBtn = document.getElementById('endSessionBtn');
if (endSessionBtn) {
endSessionBtn.addEventListener('click', endSessionHandler);
console.log("End session button handler attached");
} else {
console.error("End session button not found in the DOM");
}
// Initialize tab scrolling functionality
setupTabScrolling();
// Update button states based on current session status
updateButtonStates();
}
// Update button states based on active session
function updateButtonStates() {
if (activeSession) {
// When a session is active
if (startSessionBtn) startSessionBtn.disabled = true;
const endSessionBtn = document.getElementById('endSessionBtn');
if (endSessionBtn) endSessionBtn.disabled = false;
const addManualEntryBtn = document.getElementById('addManualEntryBtn');
if (addManualEntryBtn) addManualEntryBtn.style.display = 'inline-block';
console.log("Buttons updated for active session");
} else {
// When no session is active
if (startSessionBtn) startSessionBtn.disabled = false;
const endSessionBtn = document.getElementById('endSessionBtn');
if (endSessionBtn) endSessionBtn.disabled = true;
const addManualEntryBtn = document.getElementById('addManualEntryBtn');
if (addManualEntryBtn) addManualEntryBtn.style.display = 'none';
console.log("Buttons updated for inactive session");
}
}
tabs.forEach(tab => {
tab.addEventListener('click', () => {
const tabId = tab.getAttribute('data-tab');
tabs.forEach(t => t.classList.remove('active'));
tabContents.forEach(tc => tc.classList.remove('active'));
tab.classList.add('active');
document.getElementById(tabId).classList.add('active');
// Update connection status when backup tab is selected
if (tabId === 'backup') {
updateConnectionStatus();
updateLastBackupTimeDisplay();
}
});
});
// GitHub backup event listeners
if (backupBtn) {
backupBtn.addEventListener('click', () => backupToGitHub(false));
}
if (saveTokenBtn) {
saveTokenBtn.addEventListener('click', saveGitHubToken);
}
// Close Modal
closeSessionBtn.addEventListener('click', () => {
sessionModal.style.display = 'none';
});
// Start new scanning session
confirmSessionBtn.addEventListener('click', () => {
const location = locationInput.value.trim();
if (!location) {
alert('Please enter a location');
return;
}
// Hide modal
sessionModal.style.display = 'none';
// Create new session
const now = new Date();
const sessionId = `session_${now.getTime()}`;
const formattedDateTime = formatDateTime(now);
activeSession = {
id: sessionId,
location: location,
dateTime: now.toISOString(),
formattedDateTime: formattedDateTime,
scans: [],
inProgress: true // Flag to indicate session is in progress
};
// Add the session to the completed sessions array immediately
// This ensures it's in history even if app crashes
sessions.push(activeSession);
// Save the session index for recovery purposes
localStorage.setItem(TEMP_SESSION_INDEX_KEY, sessions.length - 1);
// Update UI
currentLocation.textContent = location;
currentDateTime.textContent = formattedDateTime;
sessionInfo.style.display = 'block';
// Start camera
startCamera();
// Clear previous results
resultBody.innerHTML = '';
resultTable.style.display = 'none';
noScansMessage.style.display = 'block';
// Start auto-save interval
startAutoSave();
// Save all sessions to storage
saveSessionsToStorage();
// Save the active session separately for recovery
saveActiveSession();
// Update button states
updateButtonStates();
// Update history view to show the new session
updateHistoryView();
});
//========================================================================================================== SESSION MANAGEMENT ========//
// Start auto-save interval
function startAutoSave() {
// Clear any existing interval
if (autoSaveInterval) {
clearInterval(autoSaveInterval);
}
// Set new interval
autoSaveInterval = setInterval(() => {
if (activeSession) {
console.log("Auto-saving session data...");
// Save to both active session storage and the history
saveActiveSession();
saveSessionsToStorage();
// Update history view to reflect changes
updateHistoryView();
}
}, AUTO_SAVE_DELAY);
}
// Stop auto-save interval
function stopAutoSave() {
if (autoSaveInterval) {
clearInterval(autoSaveInterval);
autoSaveInterval = null;
}
}
// End session handler
function endSessionHandler() {
if (!activeSession) {
console.log("No active session to end");
return;
}
console.log("Ending session:", activeSession.id);
// Confirm if there are no scans
if (activeSession.scans.length === 0) {
if (!confirm("No scans detected in this session. Do you still want to end it?")) {
return;
}
}
// Use the renamed function to stop scanner and clean up camera
stopScanner();
stopAutoSave();
// Save the session before performing operations on it
const sessionToExport = { ...activeSession };
// Mark session as completed in the sessions array
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex].inProgress = false;
console.log("Session marked as completed:", activeSession.id);
} else {
console.warn("Could not find active session in sessions array");
}
// Save sessions to storage before clearing active session
saveSessionsToStorage();
// Clear active session storage since it's complete
localStorage.removeItem(ACTIVE_SESSION_STORAGE_KEY);
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
// Update UI - Reset all elements to pre-session state
sessionInfo.style.display = 'none';
// Explicitly hide the result table
resultTable.style.display = 'none';
// Clear result body and reset no scans message
resultBody.innerHTML = '';
noScansMessage.style.display = 'none';
// Show scanner placeholder
scannerPlaceholder.style.display = 'block';
// Hide manual entry button
const addManualEntryBtn = document.getElementById('addManualEntryBtn');
if (addManualEntryBtn) {
addManualEntryBtn.style.display = 'none';
}
// Clear active session BEFORE updating button states
activeSession = null;
// Update button states - specifically enable the start session button
if (startSessionBtn) {
startSessionBtn.disabled = false;
// Make sure we're using the right event handler
startSessionBtn.removeEventListener('click', endSessionHandler);
startSessionBtn.addEventListener('click', startSessionBtnHandler);
}
// Update all other button states
updateButtonStates();
// Update history view
updateHistoryView();
// Export the session to Excel after all UI updates - if there are scans
if (sessionToExport && sessionToExport.scans && sessionToExport.scans.length > 0) {
setTimeout(() => {
console.log("Exporting session to Excel");
exportSession(sessionToExport);
}, 500);
}
console.log("Session ended successfully");
}
// Start session button handler
function startSessionBtnHandler() {
// Before showing the modal, verify if jsQR is loaded
if (!jsQRLoaded) {
loadJsQR()
.then(() => {
sessionModal.style.display = 'block';
locationInput.focus();
})
.catch(() => {
alert("Failed to load QR scanning library. Please check if jsQR.min.js is in the correct location and refresh the page.");
});
} else {
sessionModal.style.display = 'block';
locationInput.focus();
}
}
//========================================================================================================== CAMERA & SCANNER FUNCTIONS ========//
// Improved camera initialization function
// Improved camera initialization function
async function startCamera() {
try {
// Create scanner UI elements
setupScannerUI();
// Try to get camera access with optimized settings
const constraints = {
video: {
facingMode: 'environment',
width: { ideal: 1280 },
height: { ideal: 720 },
// OPTIMIZATION: Request additional settings for better performance
frameRate: { ideal: 30 },       // Higher frame rate for smoother scanning
focusMode: { ideal: "continuous" }, // Continuous auto-focus
exposureMode: { ideal: "continuous" }, // Continuous auto-exposure
whiteBalanceMode: { ideal: "continuous" }
}
};
console.log("Requesting camera access with constraints:", constraints);
videoStream = await navigator.mediaDevices.getUserMedia(constraints);
console.log("Camera access granted:", videoStream);
// Get the actual track settings
const videoTrack = videoStream.getVideoTracks()[0];
// OPTIMIZATION: Apply custom settings if the camera supports them
try {
const capabilities = videoTrack.getCapabilities();
const settings = {};
// Optimize focus for barcode scanning if supported
if (capabilities.focusDistance) {
settings.focusMode = 'manual';
// A mid-range focus distance often works well for QR codes
settings.focusDistance = (capabilities.focusDistance.max + capabilities.focusDistance.min) / 2;
}
// Optimize exposure for QR codes if supported
if (capabilities.exposureTime) {
// Shorter exposure time reduces blur with motion
settings.exposureTime = capabilities.exposureTime.min * 2;
}
// Apply optimized settings if any
if (Object.keys(settings).length > 0) {
await videoTrack.applyConstraints({ advanced: [settings] });
console.log("Applied optimized camera settings:", settings);
}
} catch (settingsError) {
// Non-critical error, continue without custom settings
console.warn("Could not apply custom camera settings:", settingsError);
}
// Set up video element
video.srcObject = videoStream;
video.setAttribute("playsinline", true);
video.onloadedmetadata = () => {
console.log(`Video ready: ${video.videoWidth}x${video.videoHeight}`);
// OPTIMIZATION: Set canvas dimensions to match video
canvasElement.width = video.videoWidth;
canvasElement.height = video.videoHeight;
// OPTIMIZATION: Improve rendering performance
canvas.imageSmoothingEnabled = false; // Disable anti-aliasing for better QR detection
// Start batch mode automatically
startBatchMode();
// Start video playback
video.play()
.then(() => {
console.log("Video playback started");
scannerPlaceholder.style.display = 'none';
video.style.display = 'block';
// Start scanning
scanning = true;
requestAnimationFrame(scanQRCode);
// Show scanning indicator
updateScanStatus('Camera active - looking for QR codes');
// OPTIMIZATION: Add batch mode indicator
addScanLogEntry('Continuous & batch scanning enabled', 'info');
})
.catch(error => {
console.error("Video playback failed:", error);
alert("Failed to start video playback. Please try again.");
});
};
} catch (error) {
console.error("Camera access error:", error);
alert(`Failed to access camera: ${error.message}. Please check camera permissions.`);
}
}
// Stop the scanner and release camera resources
function stopScanner() {
console.log("Stopping scanner...");
// Stop scanning loop
scanning = false;
// Stop the video stream if it exists
if (videoStream) {
videoStream.getTracks().forEach(track => {
track.stop();
console.log("Camera track stopped");
});
videoStream = null;
}
// Reset video element
if (video) {
video.srcObject = null;
video.style.display = 'none';
}
// Show placeholder
if (scannerPlaceholder) {
scannerPlaceholder.style.display = 'block';
}
// Clear scanner UI elements
const scannerUIElements = document.querySelectorAll('.scanner-ui');
scannerUIElements.forEach(el => el.remove());
// Reset scan status
updateScanStatus('Scanner stopped');
console.log("Scanner stopped successfully");
}
// Set up scanner UI elements
function setupScannerUI() {
// Remove any existing UI elements first
const oldElements = document.querySelectorAll('.scanner-ui');
oldElements.forEach(el => el.remove());
// Add scan frame indicator
const scanFrame = document.createElement('div');
scanFrame.className = 'scanner-ui';
scanFrame.id = 'scan-frame';
scanFrame.style.position = 'absolute';
scanFrame.style.top = '50%';
scanFrame.style.left = '50%';
scanFrame.style.transform = 'translate(-50%, -50%)';
scanFrame.style.width = '200px';
scanFrame.style.height = '200px';
scanFrame.style.border = '2px solid #24325f';
scanFrame.style.borderRadius = '10px';
scanFrame.style.boxShadow = '0 0 0 2000px rgba(0, 0, 0, 0.3)';
scanFrame.style.zIndex = '99';
document.querySelector('.scanner-container').appendChild(scanFrame);
// Add status text
const statusText = document.createElement('div');
statusText.className = 'scanner-ui';
statusText.id = 'scan-status';
statusText.style.position = 'absolute';
statusText.style.bottom = '10px';
statusText.style.left = '50%';
statusText.style.transform = 'translateX(-50%)';
statusText.style.backgroundColor = 'rgba(0,0,0,0.7)';
statusText.style.color = 'white';
statusText.style.padding = '8px 16px';
statusText.style.borderRadius = '20px';
statusText.style.zIndex = '100';
statusText.textContent = 'Starting camera...';
document.querySelector('.scanner-container').appendChild(statusText);
// Add scan log panel
const scanLogPanel = document.createElement('div');
scanLogPanel.className = 'scanner-ui';
scanLogPanel.id = 'scan-log';
scanLogPanel.style.position = 'absolute';
scanLogPanel.style.top = '10px';
scanLogPanel.style.right = '10px';
scanLogPanel.style.width = '250px';
scanLogPanel.style.maxHeight = '150px';
scanLogPanel.style.overflowY = 'auto';
scanLogPanel.style.backgroundColor = 'rgba(0,0,0,0.7)';
scanLogPanel.style.color = 'white';
scanLogPanel.style.padding = '8px';
scanLogPanel.style.borderRadius = '8px';
scanLogPanel.style.fontSize = '14px';
scanLogPanel.style.zIndex = '100';
scanLogPanel.innerHTML = '<div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Scan Log</div>';
document.querySelector('.scanner-container').appendChild(scanLogPanel);
// This is crucial for QR detection to work
canvasElement.className = 'scanner-ui';
canvasElement.style.position = 'absolute';
canvasElement.style.top = '0';
canvasElement.style.left = '0';
canvasElement.style.width = '100%';
canvasElement.style.height = '100%';
canvasElement.style.display = 'none'; 
document.querySelector('.scanner-container').appendChild(canvasElement);
}
// Add a log entry to the scan log
function addScanLogEntry(message, type = 'info') {
// Skip empty messages
if (!message || message.trim() === '') {
return;
}
const scanLog = document.getElementById('scan-log');
if (scanLog) {
const entry = document.createElement('div');
entry.style.borderBottom = '1px solid rgba(255,255,255,0.2)';
entry.style.padding = '4px 0';
entry.style.fontSize = '12px';
// Color code by type
if (type === 'success') {
entry.style.color = '#4caf50';
} else if (type === 'error') {
entry.style.color = '#f44336';
} else if (type === 'warning') {
entry.style.color = '#ff9800';
}
// Add timestamp
const now = new Date();
const timestamp = `${padZero(now.getHours())}:${padZero(now.getMinutes())}:${padZero(now.getSeconds())}`;
entry.innerHTML = `<small>${timestamp}</small> ${message}`;
scanLog.appendChild(entry);
// Scroll to bottom
scanLog.scrollTop = scanLog.scrollHeight;
// Limit entries to keep performance good
while (scanLog.children.length > 20) {
scanLog.removeChild(scanLog.children[1]); // Keep the header
}
}
}
// Highlight QR code when found
function highlightQR(location) {
const frame = document.getElementById('scan-frame');
if (frame) {
frame.style.borderColor = '#FF3B58';
setTimeout(() => {
frame.style.borderColor = '#24325f';
}, 500);
}
}
// Update scan status message
function updateScanStatus(message) {
const statusEl = document.getElementById('scan-status');
if (statusEl) {
statusEl.textContent = message;
// Add visual indication of status
if (message.includes('Successfully')) {
statusEl.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';  // Green background for success
// Briefly show success then reset
setTimeout(() => {
statusEl.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
}, 5000);
} else if (message.includes('Error') || message.includes('failed')) {
statusEl.style.backgroundColor = 'rgba(220, 0, 0, 0.8)';  // Red background for errors
} else if (message.includes('Duplicate')) {
statusEl.style.backgroundColor = 'rgba(255, 165, 0, 0.8)';  // Orange for duplicates
} else {
statusEl.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';  // Default color
}
}
}
// QR code scanning function 
function scanQRCode() {
if (!scanning) return;
if (video.readyState === video.HAVE_ENOUGH_DATA) {
try {
// Draw the video frame to the canvas
canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
// Get image data from the canvas
const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
// Check if we have valid image data
if (imageData.data.length === 0 || imageData.width === 0 || imageData.height === 0) {
console.error("Invalid image data");
updateScanStatus('Error: Invalid image data');
requestAnimationFrame(scanQRCode);
return;
}
// Verify jsQR is available
if (typeof jsQR !== 'function') {
console.error("jsQR is not available. Current value:", jsQR);
updateScanStatus('QR scanner not loaded correctly');
loadJsQR().catch(err => console.error("Failed to reload jsQR:", err));
requestAnimationFrame(scanQRCode);
return;
}
// Process multiple QR codes at once (new feature)
try {
// First try the standard method for single QR code
const code = jsQR(imageData.data, imageData.width, imageData.height, {
inversionAttempts: "dontInvert"
});
if (code && code.data) {
// Process the primary QR code
handleQRCode(code);
// OPTIMIZATION: Try to scan for additional QR codes in the same frame
// This is a simplified approach - for true multi-code scanning, 
// a more advanced library would be better
const darkAreas = detectPotentialQRRegions(imageData);
if (darkAreas.length > 0) {
// Only process a reasonable number of regions to maintain performance
const regionsToProcess = Math.min(darkAreas.length, 3);
for (let i = 0; i < regionsToProcess; i++) {
const region = darkAreas[i];
// Skip the region that's likely the same as our already detected code
if (isOverlapping(region, code.location)) continue;
// Extract and process potential QR code
const regionData = extractRegionData(imageData, region);
const regionCode = jsQR(regionData.data, regionData.width, regionData.height, {
inversionAttempts: "dontInvert"
});
if (regionCode && regionCode.data && regionCode.data !== code.data) {
handleQRCode(regionCode);
}
}
}
} else {
// No QR code found in this frame
updateScanStatus('Scanning... Position QR code in the frame');
}
} catch (qrError) {
console.error("jsQR processing error:", qrError);
updateScanStatus('QR processing error: ' + qrError.message);
}
} catch (error) {
console.error("Error in scan process:", error);
updateScanStatus('Error in scan process: ' + error.message);
}
} else {
updateScanStatus('Waiting for camera...');
}
// Continue scanning - OPTIMIZATION: Use faster refresh rate for smoother scanning
setTimeout(() => requestAnimationFrame(scanQRCode), 10);
}
// Helper function to handle detected QR codes
function handleQRCode(code) {
if (!code.data || code.data.trim() === '') {
return;
}
// Check if this code is already in our session
const alreadyScannedInSession = activeSession.scans.some(scan => scan.content === code.data);
// Check if this code was recently scanned (to prevent rapid duplicates)
if (!lastScannedCodes.has(code.data) && !alreadyScannedInSession) {
// Add to recent scans set and set timeout to remove
lastScannedCodes.add(code.data);
setTimeout(() => {
lastScannedCodes.delete(code.data);
}, 3000); // Prevent duplicate scans for 3 seconds
// Highlight the QR code
highlightQR(code.location);
if (batchModeActive) {
// Add to batch buffer
if (!batchBuffer.has(code.data)) {
batchBuffer.add(code.data);
updateBatchIndicator();
// Visual feedback
updateScanStatus(`Added to batch: ${code.data.substring(0, 20)}${code.data.length > 20 ? '...' : ''}`);
addScanLogEntry(`Queued: ${code.data.substring(0, 15)}${code.data.length > 15 ? '...' : ''}`, 'info');
// Play a shorter sound for batch additions
playSuccessSound();
}
} else {
// Process immediately if not in batch mode
playSuccessSound();
processScannedCode(code.data);
}
} else if (alreadyScannedInSession) {
// Already in session
updateScanStatus(`Already scanned: ${code.data.substring(0, 20)}${code.data.length > 20 ? '...' : ''}`);
} else {
// Recent duplicate
updateScanStatus(`Duplicate scan: ${code.data.substring(0, 20)}${code.data.length > 20 ? '...' : ''}`);
}
}
// OPTIMIZATION: Simple detection of dark regions that might contain QR codes
function detectPotentialQRRegions(imageData) {
// This is a simplified version - a real implementation would be more sophisticated
const regions = [];
const blockSize = 20;
const threshold = 100;
for (let y = 0; y < imageData.height; y += blockSize) {
for (let x = 0; x < imageData.width; x += blockSize) {
if (isDarkRegion(imageData, x, y, blockSize, threshold)) {
regions.push({
x: Math.max(0, x - blockSize),
y: Math.max(0, y - blockSize),
width: blockSize * 3,
height: blockSize * 3
});
}
}
}
return regions;
}
// Helper to check if a region is dark (potential QR code)
function isDarkRegion(imageData, startX, startY, size, threshold) {
const endX = Math.min(startX + size, imageData.width);
const endY = Math.min(startY + size, imageData.height);
let darkPixels = 0;
let totalPixels = 0;
for (let y = startY; y < endY; y++) {
for (let x = startX; x < endX; x++) {
const idx = (y * imageData.width + x) * 4;
const r = imageData.data[idx];
const g = imageData.data[idx + 1];
const b = imageData.data[idx + 2];
const avg = (r + g + b) / 3;
if (avg < threshold) {
darkPixels++;
}
totalPixels++;
}
}
return (darkPixels / totalPixels) > 0.5;
}
// Helper to check if two regions overlap
function isOverlapping(region1, location) {
if (!location) return false;
// Convert QR location points to a bounding box
const qrPoints = [location.topLeftCorner, location.topRightCorner, 
location.bottomRightCorner, location.bottomLeftCorner];
let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
for (const point of qrPoints) {
minX = Math.min(minX, point.x);
minY = Math.min(minY, point.y);
maxX = Math.max(maxX, point.x);
maxY = Math.max(maxY, point.y);
}
const qrBox = {
x: minX,
y: minY,
width: maxX - minX,
height: maxY - minY
};
// Check if the regions overlap
return !(
region1.x + region1.width < qrBox.x ||
qrBox.x + qrBox.width < region1.x ||
region1.y + region1.height < qrBox.y ||
qrBox.y + qrBox.height < region1.y
);
}
// Helper to extract region data for processing
function extractRegionData(imageData, region) {
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
// Ensure we don't exceed image boundaries
const width = Math.min(region.width, imageData.width - region.x);
const height = Math.min(region.height, imageData.height - region.y);
canvas.width = width;
canvas.height = height;
// Create a new ImageData object for the region
const regionImgData = ctx.createImageData(width, height);
// Copy pixel data
for (let y = 0; y < height; y++) {
for (let x = 0; x < width; x++) {
const sourceIdx = ((region.y + y) * imageData.width + (region.x + x)) * 4;
const destIdx = (y * width + x) * 4;
regionImgData.data[destIdx] = imageData.data[sourceIdx];
regionImgData.data[destIdx + 1] = imageData.data[sourceIdx + 1];
regionImgData.data[destIdx + 2] = imageData.data[sourceIdx + 2];
regionImgData.data[destIdx + 3] = imageData.data[sourceIdx + 3];
}
}
return regionImgData;
}
// Function to start batch mode (call this after starting the camera)
function startBatchMode() {
if (batchProcessingInterval) {
clearInterval(batchProcessingInterval);
}
batchBuffer.clear();
batchModeActive = true;
// Process the batch every 2 seconds
batchProcessingInterval = setInterval(processBatch, 2000);
// Update UI to show batch mode is active
addScanLogEntry('Batch mode active - Scanning multiple codes', 'info');
// Add batch mode indicator to scanner UI if it doesn't exist
if (!document.getElementById('batch-indicator')) {
const batchIndicator = document.createElement('div');
batchIndicator.className = 'scanner-ui';
batchIndicator.id = 'batch-indicator';
batchIndicator.style.position = 'absolute';
batchIndicator.style.top = '10px';
batchIndicator.style.left = '10px';
batchIndicator.style.backgroundColor = 'rgba(0,128,0,0.7)';
batchIndicator.style.color = 'white';
batchIndicator.style.padding = '5px 10px';
batchIndicator.style.borderRadius = '15px';
batchIndicator.style.fontSize = '12px';
batchIndicator.style.zIndex = '100';
batchIndicator.innerHTML = '⚡ Batch Mode';
document.querySelector('.scanner-container').appendChild(batchIndicator);
}
}
// Function to stop batch mode
function stopBatchMode() {
if (batchProcessingInterval) {
clearInterval(batchProcessingInterval);
batchProcessingInterval = null;
}
// Process any remaining codes in the buffer
processBatch();
batchModeActive = false;
// Remove batch indicator if it exists
const batchIndicator = document.getElementById('batch-indicator');
if (batchIndicator) {
batchIndicator.remove();
}
addScanLogEntry('Batch mode deactivated', 'info');
}
// Update batch indicator with current count
function updateBatchIndicator() {
const indicator = document.getElementById('batch-indicator');
if (indicator) {
indicator.innerHTML = `⚡ Batch: ${batchBuffer.size}`;
// Visual feedback for batch size
if (batchBuffer.size > 0) {
indicator.style.backgroundColor = 'rgba(0,128,0,0.7)';
}
}
}
// Process all codes in the batch buffer
function processBatch() {
if (processingBatch || batchBuffer.size === 0) return;
processingBatch = true;
try {
const batchSize = batchBuffer.size;
// Show batch processing notification
updateScanStatus(`Processing batch of ${batchSize} codes...`);
// Process each code in the buffer
batchBuffer.forEach(code => {
processScannedCode(code);
});
// Clear the buffer after processing
batchBuffer.clear();
updateBatchIndicator();
// Confirmation of batch processing
updateScanStatus(`✅ Processed batch of ${batchSize} codes successfully`);
addScanLogEntry(`Processed batch of ${batchSize} codes`, 'success');
// Play a success sound for the whole batch
playSuccessSound();
} catch (error) {
console.error("Error processing batch:", error);
updateScanStatus(`Error processing batch: ${error.message}`);
addScanLogEntry(`Batch processing error: ${error.message}`, 'error');
} finally {
processingBatch = false;
}
}
//========================================================================================================== QR DATA PROCESSING ========//
// Process scanned QR code 
function processScannedCode(data) {
// Additional validation to ensure we're not adding empty codes
if (!data || data.trim() === '') {
console.error("Attempted to process empty QR code data");
updateScanStatus('Error: Empty QR code data');
addScanLogEntry('Empty QR code data - not saved', 'error');
return;
}
const now = new Date();
const scan = {
id: activeSession.scans.length + 1,
content: data,
time: now.toISOString(),
formattedTime: formatTime(now)
};
// Add to active session
activeSession.scans.push(scan);
// Update UI
if (activeSession.scans.length === 1) {
noScansMessage.style.display = 'none';
resultTable.style.display = 'table';
}
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
resultBody.appendChild(row);
// Find the session in the sessions array and update it
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex] = {...activeSession};
}
// Save both active session and completed sessions
saveActiveSession();
saveSessionsToStorage();
// Add to scan log
addScanLogEntry(`Saved: ${data.substring(0, 15)}${data.length > 15 ? '...' : ''}`, 'success');
}
// End current scanning session - Renamed from stopScanner
function endScanningSession() {
// Stop batch mode if active
if (batchModeActive) {
stopBatchMode();
}
if (scanning) {
scanning = false;
// Stop auto-save
stopAutoSave();
// Stop camera
if (videoStream) {
videoStream.getTracks().forEach(track => track.stop());
videoStream = null;
}
// Update UI
video.style.display = 'none';
scannerPlaceholder.style.display = 'block';
// Clean up UI elements
const scannerUI = document.querySelectorAll('.scanner-ui');
scannerUI.forEach(el => el.remove());
// Update session status in the array
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
// Update the session to mark it as completed
sessions[sessionIndex].inProgress = false;
// Save to storage
saveSessionsToStorage();
// Update history view
updateHistoryView();
// Auto-export this session
exportSession(sessions[sessionIndex]);
}
// Clear the active session storage
clearActiveSession();
// Clear the temp session index
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
// Reset UI
sessionInfo.style.display = 'none';
startSessionBtn.textContent = 'Start Scanning Session';
startSessionBtn.removeEventListener('click', endSessionHandler);
startSessionBtn.addEventListener('click', startSessionBtnHandler);
// Show confirmation
alert('Session completed and exported successfully!');
// Reset active session
activeSession = null;
}
}
// Handler for start session button
function startSessionBtnHandler() {
// Check if jsQR is loaded
if (!jsQRLoaded) {
loadJsQR()
.then(() => {
sessionModal.style.display = 'block';
locationInput.focus();
})
.catch(() => {
alert("Failed to load QR scanning library. Please check if jsQR.min.js is in the correct location and refresh the page.");
});
} else {
sessionModal.style.display = 'block';
locationInput.focus();
}
}
// Export all history to Excel
exportAllBtn.addEventListener('click', () => {
if (sessions.length === 0) {
alert('No sessions to export');
return;
}
try {
// Add a delay to prevent rapid multiple clicks
exportAllBtn.disabled = true;
// Execute the export
exportAllSessions();
// Re-enable the button after 2 seconds
setTimeout(() => {
exportAllBtn.disabled = false;
}, 2000);
console.log("Export all completed successfully");
} catch (error) {
console.error("Export failed:", error);
alert("Export failed: " + error.message);
exportAllBtn.disabled = false;
}
});
// Sort history sessions
sortBy.addEventListener('change', updateHistoryView);
// Export single session
exportSessionBtn.addEventListener('click', () => {
if (!activeSessionId) return;
const session = sessions.find(s => s.id === activeSessionId);
if (session) {
exportSession(session);
}
});
// Close session details
closeDetailsBtn.addEventListener('click', () => {
sessionDetails.style.display = 'none';
});
//========================================================================================================== CHECKLIST MODULE ========//
// Constants for checklist module
const CHECKLIST_ACTIVE_SESSION_STORAGE_KEY = 'activeChecklistSession';
const TEMP_CHECKLIST_SESSION_INDEX_KEY = 'tempChecklistSessionIndex';
// DOM Elements for Checklist
const startChecklistSessionBtn = document.getElementById('startChecklistSessionBtn');
const endChecklistSessionBtn = document.getElementById('endChecklistSessionBtn');
const addCustomEntryBtn = document.getElementById('addCustomEntryBtn');
const checklistLocation = document.getElementById('checklistLocation');
const checklistDateTime = document.getElementById('checklistDateTime');
const checklistSessionInfo = document.getElementById('checklistSessionInfo');
const checklistContainer = document.querySelector('.checklist-container');
const closeChecklistBtn = document.getElementById('closeChecklistBtn');
const studentsChecklist = document.getElementById('studentsChecklist');
const studentSearchInput = document.getElementById('studentSearchInput');
const selectionTable = document.getElementById('selectionTable');
const selectionBody = document.getElementById('selectionBody');
const noSelectionsMessage = document.getElementById('noSelectionsMessage');
const checklistModal = document.getElementById('checklistModal');
const closeChecklistModalBtn = document.getElementById('closeChecklistModalBtn');
const confirmChecklistBtn = document.getElementById('confirmChecklistBtn');
const checklistLocationInput = document.getElementById('checklistLocationInput');
// State variables for checklist
let checklistActiveSession = null;
let studentsData = [];
let selectedStudents = new Set();
// Initialize checklist functionality
function initializeChecklistModule() {
// Ensure the checklist container has proper styling
const style = document.createElement('style');
style.textContent = `
.checklist-container {
margin-top: 1rem;
border: 1px solid #ddd;
border-radius: 8px;
background-color: #f9f9f9;
padding: 1rem;
}
#studentsChecklist {
height: 300px;
overflow-y: auto;
border: 1px solid #ddd;
border-radius: 4px;
padding: 0.5rem;
background-color: white;
}
`;
document.head.appendChild(style);
// Load students data from Excel file
loadStudentsData();
// Event listeners for checklist buttons
startChecklistSessionBtn.addEventListener('click', startChecklistSession);
endChecklistSessionBtn.addEventListener('click', endChecklistSession);
addCustomEntryBtn.addEventListener('click', showAddCustomEntryModal);
closeChecklistBtn.addEventListener('click', closeChecklist);
// Add event listeners for checklist modal
if(closeChecklistModalBtn) {
closeChecklistModalBtn.addEventListener('click', () => {
checklistModal.style.display = 'none';
});
}
if(confirmChecklistBtn) {
confirmChecklistBtn.addEventListener('click', confirmChecklistSession);
}
// Search functionality
studentSearchInput.addEventListener('input', filterStudents);
// Check for recoverable checklist session
checkForRecoverableChecklistSession();
// Update checklist button states
updateChecklistButtonStates();
// Add beforeunload event listener specifically for checklist
window.addEventListener('beforeunload', handleChecklistBeforeUnload);
console.log("Checklist module initialized");
}
// Update checklist button states based on active session
function updateChecklistButtonStates() {
if (checklistActiveSession) {
// When a checklist session is active
if (startChecklistSessionBtn) startChecklistSessionBtn.disabled = true;
if (endChecklistSessionBtn) endChecklistSessionBtn.disabled = false;
if (addCustomEntryBtn) addCustomEntryBtn.style.display = 'inline-block';
console.log("Checklist buttons updated for active session");
} else {
// When no checklist session is active
if (startChecklistSessionBtn) startChecklistSessionBtn.disabled = false;
if (endChecklistSessionBtn) endChecklistSessionBtn.disabled = true;
if (addCustomEntryBtn) addCustomEntryBtn.style.display = 'none';
console.log("Checklist buttons updated for inactive session");
}
}
// Save active checklist session to local storage
function saveActiveChecklistSession() {
if (checklistActiveSession) {
try {
localStorage.setItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY, JSON.stringify(checklistActiveSession));
console.log("Active checklist session saved", checklistActiveSession.id, checklistActiveSession.scans.length, "selections");
} catch (error) {
console.error("Error saving active checklist session:", error);
}
}
}
// Clear active checklist session from local storage
function clearActiveChecklistSession() {
try {
localStorage.removeItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY);
localStorage.removeItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
console.log("Active checklist session cleared from storage");
} catch (error) {
console.error("Error clearing active checklist session:", error);
}
}
// Check for a recoverable checklist session
function checkForRecoverableChecklistSession() {
try {
// First check for active checklist session
const savedActiveChecklistSession = localStorage.getItem(CHECKLIST_ACTIVE_SESSION_STORAGE_KEY);
const tempChecklistSessionIndex = localStorage.getItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
if (savedActiveChecklistSession) {
const parsedSession = JSON.parse(savedActiveChecklistSession);
if (parsedSession && parsedSession.id && parsedSession.scans && parsedSession.isChecklist) {
const result = confirm(`Found an incomplete checklist session at ${parsedSession.location} with ${parsedSession.scans.length} selections. Would you like to recover it?`);
if (result) {
// Recover the checklist session
recoverChecklistSession(parsedSession);
} else {
// Mark the session as completed in history if it exists there
const sessionIndex = sessions.findIndex(s => s.id === parsedSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex].inProgress = false;
saveSessionsToStorage();
}
// Clear the session
clearActiveChecklistSession();
}
return; // Don't proceed to next check if we've handled this one
}
}
// If no active session, check if there's a checklist session in progress in history
if (tempChecklistSessionIndex !== null) {
const index = parseInt(tempChecklistSessionIndex);
if (!isNaN(index) && index >= 0 && index < sessions.length) {
const tempSession = sessions[index];
if (tempSession && tempSession.inProgress && tempSession.isChecklist) {
const result = confirm(`Found an incomplete checklist session at ${tempSession.location} with ${tempSession.scans.length} selections in history. Would you like to recover it?`);
if (result) {
// Recover the session from history
recoverChecklistSession(tempSession);
} else {
// Mark as completed
sessions[index].inProgress = false;
saveSessionsToStorage();
localStorage.removeItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
}
}
} else {
// Invalid index for checklist, clear it
localStorage.removeItem(TEMP_CHECKLIST_SESSION_INDEX_KEY);
}
}
} catch (error) {
console.error("Error checking for recoverable checklist session:", error);
// Clear potentially corrupted data
clearActiveChecklistSession();
}
}
// Recover checklist session
function recoverChecklistSession(session) {
checklistActiveSession = session;
// Make sure the session has inProgress flag set
checklistActiveSession.inProgress = true;
// Update UI
checklistLocation.textContent = session.location;
checklistDateTime.textContent = session.formattedDateTime;
checklistSessionInfo.style.display = 'block';
checklistContainer.style.display = 'block';
// Populate the checklist with student data
populateStudentChecklist();
// Restore selections
selectedStudents = new Set();
session.scans.forEach(scan => {
selectedStudents.add(scan.id);
// Check the corresponding checkboxes
const checkbox = document.getElementById(`student_${scan.id}`);
if (checkbox) {
checkbox.checked = true;
}
});
// Update selection table
updateSelectionTable();
// Check if session exists in the sessions array
const sessionIndex = sessions.findIndex(s => s.id === session.id);
if (sessionIndex === -1) {
// Session doesn't exist in sessions array, add it
sessions.push(session);
} else {
// Update existing session
sessions[sessionIndex] = {...session};
}
// Save to storage
saveSessionsToStorage();
saveActiveChecklistSession();
// Store the session index for recovery
const index = sessions.findIndex(s => s.id === session.id);
if (index !== -1) {
localStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, index);
}
// Switch to checklist tab if not already there
const checklistTab = document.querySelector('[data-tab="checklist"]');
const checklistContent = document.getElementById('checklist');
if (checklistTab && checklistContent) {
tabs.forEach(t => t.classList.remove('active'));
tabContents.forEach(tc => tc.classList.remove('active'));
checklistTab.classList.add('active');
checklistContent.classList.add('active');
}
// Update button states
updateChecklistButtonStates();
console.log("Checklist session recovered successfully");
}
// Warn user before closing the page during active checklist session
function handleChecklistBeforeUnload(event) {
if (checklistActiveSession) {
// Save one last time
saveActiveChecklistSession();
saveSessionsToStorage();
// Show confirmation dialog
const message = "You have an active checklist session. Are you sure you want to leave?";
event.returnValue = message;
return message;
}
}
// Load students data from the Excel file
function loadStudentsData() {
console.log("Loading students data from Excel...");
// Try to fetch the Excel file
fetch('students_ids.xlsx')
.then(response => {
if (!response.ok) {
throw new Error('Failed to load students data file');
}
return response.arrayBuffer();
})
.then(buffer => {
// Parse the Excel file using XLSX library
const data = new Uint8Array(buffer);
const workbook = XLSX.read(data, { type: 'array' });
// Get the first sheet
const firstSheetName = workbook.SheetNames[0];
const worksheet = workbook.Sheets[firstSheetName];
// Convert to JSON
const jsonData = XLSX.utils.sheet_to_json(worksheet);
// Process the data to ensure consistent property names
studentsData = jsonData.map(student => {
const processedStudent = {};
// Loop through all properties to find year, group and ID regardless of case
Object.keys(student).forEach(key => {
const lowerKey = key.toLowerCase();
if (lowerKey.includes('year')) {
processedStudent.year = student[key];
}
if (lowerKey.includes('group')) {
processedStudent.group = student[key];
}
if (lowerKey.includes('id')) {
processedStudent.id = student[key];
}
});
return processedStudent;
});
console.log("Students data loaded:", studentsData.length, "records");
// If checklist is active, refresh the view
if (checklistActiveSession) {
populateStudentChecklist();
}
})
.catch(error => {
console.error("Error loading students data:", error);
// Create empty array if file doesn't exist
studentsData = [];
});
}
// Start a new checklist session
function startChecklistSession() {
console.log("Starting checklist session...");
// Display the checklist-specific modal
if(checklistModal) {
checklistModal.style.display = 'block';
checklistLocationInput.focus();
} else {
// Fallback if modal doesn't exist - create a simple prompt
const location = prompt('Enter location for checklist session:');
if(location) {
createNewChecklistSession(location);
}
}
}
// Create a new checklist session with the provided location
function createNewChecklistSession(location) {
if (!location) {
alert('Please enter a location');
return;
}
// Create new session
const now = new Date();
const sessionId = `checklist_${now.getTime()}`;
const formattedDateTime = formatDateTime(now);
checklistActiveSession = {
id: sessionId,
location: location,
dateTime: now.toISOString(),
formattedDateTime: formattedDateTime,
scans: [], // Using the same structure as scanner for compatibility
inProgress: true,
isChecklist: true // Flag to identify checklist sessions
};
// Update UI
checklistLocation.textContent = location;
checklistDateTime.textContent = formattedDateTime;
checklistSessionInfo.style.display = 'block';
// Show checklist container
checklistContainer.style.display = 'block';
// Populate the checklist with student data
populateStudentChecklist();
// Clear previous results
selectionBody.innerHTML = '';
selectionTable.style.display = 'none';
noSelectionsMessage.style.display = 'block';
// Update button states
updateChecklistButtonStates();
// Reset selected students
selectedStudents = new Set();
// Save active session for recovery
saveActiveChecklistSession();
// Add the session to sessions array for history
sessions.push(checklistActiveSession);
// Save to storage
saveSessionsToStorage();
// Store the session index for recovery
const index = sessions.findIndex(s => s.id === checklistActiveSession.id);
if (index !== -1) {
localStorage.setItem(TEMP_CHECKLIST_SESSION_INDEX_KEY, index);
}
console.log("New checklist session created:", sessionId);
}
// Confirm checklist session from modal
function confirmChecklistSession() {
const location = checklistLocationInput.value.trim();
// Hide modal
checklistModal.style.display = 'none';
// Create the session
createNewChecklistSession(location);
}
// Populate the student checklist from the loaded data
function populateStudentChecklist() {
studentsChecklist.innerHTML = '';
// Create a fixed-height container div for scrolling
studentsChecklist.style.height = '300px';
studentsChecklist.style.overflowY = 'auto';
studentsChecklist.style.border = '1px solid #ddd';
studentsChecklist.style.borderRadius = '4px';
studentsChecklist.style.padding = '0.5rem';
studentsChecklist.style.backgroundColor = 'white';
if (studentsData.length === 0) {
studentsChecklist.innerHTML = '<p class="no-data-message">No student data found. Please make sure students_ids.xlsx is in the correct location.</p>';
return;
}
// Create dropdown navigation
const navContainer = document.createElement('div');
navContainer.className = 'checklist-navigation';
navContainer.style.marginBottom = '15px';
navContainer.style.display = 'flex';
navContainer.style.gap = '10px';
// Create year filter
const yearSelect = document.createElement('select');
yearSelect.id = 'yearFilter';
yearSelect.style.padding = '5px';
yearSelect.style.borderRadius = '4px';
yearSelect.style.flex = '1';
// Create group filter
const groupSelect = document.createElement('select');
groupSelect.id = 'groupFilter';
groupSelect.style.padding = '5px';
groupSelect.style.borderRadius = '4px';
groupSelect.style.flex = '1';
// Group students by year and group
const grouped = {};
const years = new Set();
const groups = new Set();
studentsData.forEach(student => {
// Check all possible property names for year, group and id
const year = student.Year || student.year || 'Unknown';
const group = student.Group || student.group || 'Unknown';
const id = student.ID || student.Id || student.id || 
student['students id'] || student['student id'] || 
student['Student ID'] || student['student ID'] || 
student['Students ID'];
if (!id) return; // Skip entries without ID
// Add to sets for filters
years.add(year);
groups.add(group);
const key = `${year}_${group}`;
if (!grouped[key]) {
grouped[key] = {
year: year,
group: group,
students: []
};
}
grouped[key].students.push({
id: id,
year: year,
group: group
});
});
// Populate year filter
yearSelect.innerHTML = '<option value="all">All Years</option>';
Array.from(years).sort().forEach(year => {
const option = document.createElement('option');
option.value = year;
option.textContent = year;
yearSelect.appendChild(option);
});
// Populate group filter
groupSelect.innerHTML = '<option value="all">All Groups</option>';
Array.from(groups).sort().forEach(group => {
const option = document.createElement('option');
option.value = group;
option.textContent = group;
groupSelect.appendChild(option);
});
// Add filters to navigation
const yearLabel = document.createElement('label');
yearLabel.textContent = 'Year: ';
yearLabel.htmlFor = 'yearFilter';
yearLabel.style.fontWeight = 'bold';
const groupLabel = document.createElement('label');
groupLabel.textContent = 'Group: ';
groupLabel.htmlFor = 'groupFilter';
groupLabel.style.fontWeight = 'bold';
const yearContainer = document.createElement('div');
yearContainer.style.display = 'flex';
yearContainer.style.alignItems = 'center';
yearContainer.style.gap = '5px';
yearContainer.appendChild(yearLabel);
yearContainer.appendChild(yearSelect);
const groupContainer = document.createElement('div');
groupContainer.style.display = 'flex';
groupContainer.style.alignItems = 'center';
groupContainer.style.gap = '5px';
groupContainer.appendChild(groupLabel);
groupContainer.appendChild(groupSelect);
navContainer.appendChild(yearContainer);
navContainer.appendChild(groupContainer);
// Add navigation to checklist
studentsChecklist.appendChild(navContainer);
// Create a container for student checkboxes
const checklistContent = document.createElement('div');
checklistContent.id = 'checklistContent';
studentsChecklist.appendChild(checklistContent);
// Function to update checklist content based on filters
function updateChecklistContent() {
const selectedYear = yearSelect.value;
const selectedGroup = groupSelect.value;
checklistContent.innerHTML = '';
// Sort by year and group
const sortedKeys = Object.keys(grouped).sort();
// Filter and create the HTML structure
sortedKeys.forEach(key => {
const data = grouped[key];
// Apply filters
if ((selectedYear === 'all' || data.year === selectedYear) && 
(selectedGroup === 'all' || data.group === selectedGroup)) {
// Create section header
const sectionHeader = document.createElement('div');
sectionHeader.className = 'checklist-section-header';
sectionHeader.style.fontWeight = 'bold';
sectionHeader.style.padding = '5px';
sectionHeader.style.backgroundColor = '#f0f0f0';
sectionHeader.style.borderRadius = '4px';
sectionHeader.style.marginTop = '8px';
sectionHeader.style.position = 'sticky';
sectionHeader.style.top = '0';
sectionHeader.style.zIndex = '1';
sectionHeader.textContent = `Year: ${data.year}, Group: ${data.group}`;
checklistContent.appendChild(sectionHeader);
// Create student checkboxes
const studentList = document.createElement('div');
studentList.className = 'student-list';
studentList.style.marginBottom = '15px';
studentList.style.paddingLeft = '15px';
data.students.forEach(student => {
const checkboxContainer = document.createElement('div');
checkboxContainer.className = 'checkbox-container';
checkboxContainer.style.display = 'flex';
checkboxContainer.style.alignItems = 'center';
checkboxContainer.style.margin = '3px 0';
const checkbox = document.createElement('input');
checkbox.type = 'checkbox';
checkbox.id = `student_${student.id}`;
checkbox.value = student.id;
checkbox.dataset.id = student.id;
checkbox.style.marginRight = '8px';
// If this student is already selected, check the box
if (selectedStudents.has(student.id)) {
checkbox.checked = true;
}
const label = document.createElement('label');
label.setAttribute('for', `student_${student.id}`);
label.textContent = student.id;
checkbox.addEventListener('change', function() {
handleStudentSelection(this);
});
checkboxContainer.appendChild(checkbox);
checkboxContainer.appendChild(label);
studentList.appendChild(checkboxContainer);
});
checklistContent.appendChild(studentList);
}
});
// Show message if no students match filter
if (checklistContent.children.length === 0) {
const noMatchMessage = document.createElement('p');
noMatchMessage.style.padding = '10px';
noMatchMessage.style.textAlign = 'center';
noMatchMessage.textContent = 'No students match the selected filters.';
checklistContent.appendChild(noMatchMessage);
}
}
// Add event listeners to filters
yearSelect.addEventListener('change', updateChecklistContent);
groupSelect.addEventListener('change', updateChecklistContent);
// Initialize checklist content
updateChecklistContent();
}
// Handle student selection
function handleStudentSelection(checkbox) {
const studentId = checkbox.dataset.id;
if (checkbox.checked) {
// Add student to selected set
if (!selectedStudents.has(studentId)) {
selectedStudents.add(studentId);
addStudentToSelectionTable(studentId);
}
} else {
// Remove student from selected set
if (selectedStudents.has(studentId)) {
selectedStudents.delete(studentId);
removeStudentFromSelectionTable(studentId);
}
}
// Save active session with updates
saveActiveChecklistSession();
}
// Add student to the selection table
function addStudentToSelectionTable(studentId) {
if (!checklistActiveSession) return;
// Create timestamp
const now = new Date();
const timestamp = now.toISOString();
const formattedTime = formatTime(now);
// Add to session scans (using same format as scanner)
const newScan = {
id: studentId,
content: studentId, // Using ID as content for consistency with scanner
timestamp: timestamp,
formattedTime: formattedTime,
time: now // Add full date object for proper export formatting
};
checklistActiveSession.scans.push(newScan);
// Update UI
updateSelectionTable();
}
// Remove student from the selection table
function removeStudentFromSelectionTable(studentId) {
if (!checklistActiveSession) return;
// Remove from session scans
checklistActiveSession.scans = checklistActiveSession.scans.filter(scan => scan.id !== studentId);
// Update UI
updateSelectionTable();
}
// Update the selection table
function updateSelectionTable() {
if (!checklistActiveSession) return;
selectionBody.innerHTML = '';
if (checklistActiveSession.scans.length > 0) {
noSelectionsMessage.style.display = 'none';
selectionTable.style.display = 'table';
// Add row number for display
checklistActiveSession.scans.forEach((scan, index) => {
const row = document.createElement('tr');
row.innerHTML = `
<td>${index + 1}</td>
<td>${scan.id}</td>
<td>${scan.formattedTime}</td>
`;
selectionBody.appendChild(row);
});
} else {
noSelectionsMessage.style.display = 'block';
selectionTable.style.display = 'none';
}
// Save changes to storage
saveActiveChecklistSession();
// Update the session in the sessions array too
const sessionIndex = sessions.findIndex(s => s.id === checklistActiveSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex] = {...checklistActiveSession};
saveSessionsToStorage();
}
}
// Close checklist view but keep session active
function closeChecklist() {
checklistContainer.style.display = 'none';
}
// Filter students in the checklist based on search
function filterStudents() {
const searchTerm = studentSearchInput.value.toLowerCase();
const checkboxes = studentsChecklist.querySelectorAll('.checkbox-container');
checkboxes.forEach(container => {
const label = container.querySelector('label');
const studentId = label.textContent.toLowerCase();
if (studentId.includes(searchTerm)) {
container.style.display = 'block';
} else {
container.style.display = 'none';
}
});
// Also handle section headers visibility
const sections = studentsChecklist.querySelectorAll('.checklist-section-header');
sections.forEach(section => {
const nextSibling = section.nextElementSibling;
const visibleStudents = nextSibling.querySelectorAll('.checkbox-container[style="display: block"]').length;
if (visibleStudents > 0) {
section.style.display = 'block';
} else {
section.style.display = 'none';
}
});
}
// Show modal for manual student ID entry
function showAddCustomEntryModal() {
// Reuse existing manual entry modal
manualIdInput.value = '';
manualEntryModal.style.display = 'block';
manualIdInput.focus();
// Override the confirm button behavior temporarily
const originalConfirmFunction = confirmManualEntryBtn.onclick;
confirmManualEntryBtn.onclick = function() {
const customId = manualIdInput.value.trim();
if (!customId) {
alert('Please enter a valid student ID');
return;
}
// Add the custom ID
manualEntryModal.style.display = 'none';
// Add to selected students if not already there
if (!selectedStudents.has(customId)) {
selectedStudents.add(customId);
addStudentToSelectionTable(customId);
}
// Restore original function
confirmManualEntryBtn.onclick = originalConfirmFunction;
};
}
// End checklist session
function endChecklistSession() {
if (!checklistActiveSession) {
console.log("No active checklist session to end");
return;
}
console.log("Ending checklist session:", checklistActiveSession.id);
// Confirm if there are no selections
if (checklistActiveSession.scans.length === 0) {
if (!confirm("No students selected in this session. Do you still want to end it?")) {
return;
}
}
// Save the session for export
const sessionToExport = { ...checklistActiveSession };
// Mark the session as completed in the sessions array
const sessionIndex = sessions.findIndex(s => s.id === checklistActiveSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex].inProgress = false;
} else {
// Add the session to the main sessions array if it's not there
sessionToExport.inProgress = false;
sessions.push(sessionToExport);
}
// Save to storage
saveSessionsToStorage();
// Clear from local storage
clearActiveChecklistSession();
// Update UI - Reset all elements to pre-session state
checklistSessionInfo.style.display = 'none';
checklistContainer.style.display = 'none';
selectionTable.style.display = 'none';
selectionBody.innerHTML = '';
noSelectionsMessage.style.display = 'none';
// Clear active session
checklistActiveSession = null;
selectedStudents = new Set();
// Update button states
updateChecklistButtonStates();
// Update history view
updateHistoryView();
// Export the session to Excel
if (sessionToExport && sessionToExport.scans && sessionToExport.scans.length > 0) {
setTimeout(() => {
console.log("Exporting checklist session to Excel");
exportChecklistSession(sessionToExport);
}, 500);
}
console.log("Checklist session ended successfully");
}
// Export a checklist session to Excel (separated from main export function)
function exportChecklistSession(session) {
if (!window.XLSX) {
console.error("XLSX library not loaded");
alert("Export functionality is not available. Please check your internet connection.");
return;
}
const fileName = `Checklist_${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Prepare data with the correct structure
const data = [
['Number', 'Student ID', 'Location', 'Log Date', 'Log Time']
];
// Add scans with row numbers
session.scans.forEach((scan, index) => {
const scanDate = new Date(scan.time);
data.push([
index + 1,              // Row number
scan.content,           // Student ID
session.location,       // Location
formatDate(scanDate),   // Log Date
formatTime(scanDate)    // Log Time
]);
});
// Create workbook
const ws = XLSX.utils.aoa_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Checklist");
// First save the file locally
try {
XLSX.writeFile(wb, fileName);
console.log("Checklist Excel file saved locally:", fileName);
// After successful local save, then backup to GitHub if that functionality exists
if (typeof exportExcelToGitHub === 'function') {
setTimeout(() => {
exportExcelToGitHub(fileName, wb)
.then(() => {
console.log("GitHub backup of checklist Excel complete");
})
.catch(err => {
console.error("GitHub backup failed:", err);
});
}, 1000);
}
} catch (error) {
console.error("Error saving checklist Excel file locally:", error);
alert("Error exporting file: " + error.message);
}
}
// Add this to document ready event
document.addEventListener('DOMContentLoaded', function() {
// Initialize the checklist module
if (document.getElementById('startChecklistSessionBtn')) {
initializeChecklistModule();
}
});
//========================================================================================================== SESSION STORAGE & RECOVERY ========//
// Save active session to local storage
function saveActiveSession() {
if (activeSession) {
try {
localStorage.setItem(ACTIVE_SESSION_STORAGE_KEY, JSON.stringify(activeSession));
console.log("Active session saved", activeSession.id, activeSession.scans.length, "scans");
} catch (error) {
console.error("Error saving active session:", error);
}
}
}
// Clear active session from local storage
function clearActiveSession() {
try {
localStorage.removeItem(ACTIVE_SESSION_STORAGE_KEY);
} catch (error) {
console.error("Error clearing active session:", error);
}
}
// Check if there's a recoverable session
function checkForRecoverableSession() {
try {
// First check for active session
const savedActiveSession = localStorage.getItem(ACTIVE_SESSION_STORAGE_KEY);
const tempSessionIndex = localStorage.getItem(TEMP_SESSION_INDEX_KEY);
if (savedActiveSession) {
const parsedSession = JSON.parse(savedActiveSession);
if (parsedSession && parsedSession.id && parsedSession.scans && parsedSession.scans.length > 0) {
const result = confirm(`Found an incomplete scanning session at ${parsedSession.location} with ${parsedSession.scans.length} scans. Would you like to recover it?`);
if (result) {
// Recover the session
recoverSession(parsedSession);
} else {
// Mark the session as completed in history if it exists there
const sessionIndex = sessions.findIndex(s => s.id === parsedSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex].inProgress = false;
saveSessionsToStorage();
}
// Clear the session
clearActiveSession();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
return; // Don't proceed to next check if we've handled this one
}
}
// If no active session, check if there's a session in progress in history
if (tempSessionIndex !== null) {
const index = parseInt(tempSessionIndex);
if (!isNaN(index) && index >= 0 && index < sessions.length) {
const tempSession = sessions[index];
if (tempSession && tempSession.inProgress) {
const result = confirm(`Found an incomplete scanning session at ${tempSession.location} with ${tempSession.scans.length} scans in history. Would you like to recover it?`);
if (result) {
// Recover the session from history
recoverSession(tempSession);
} else {
// Mark as completed
sessions[index].inProgress = false;
saveSessionsToStorage();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
} else {
// Invalid index, clear it
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
} catch (error) {
console.error("Error checking for recoverable session:", error);
// Clear potentially corrupted data
clearActiveSession();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
// Recover active session 
function recoverSession(session) {
activeSession = session;
// Make sure the session has inProgress flag set
activeSession.inProgress = true;
// Update UI
currentLocation.textContent = session.location;
currentDateTime.textContent = session.formattedDateTime;
sessionInfo.style.display = 'block';
// Update scan table
resultBody.innerHTML = '';
if (session.scans.length > 0) {
noScansMessage.style.display = 'none';
resultTable.style.display = 'table';
session.scans.forEach(scan => {
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
resultBody.appendChild(row);
});
} else {
noScansMessage.style.display = 'block';
resultTable.style.display = 'none';
}
// Check if session exists in the sessions array
const sessionIndex = sessions.findIndex(s => s.id === session.id);
if (sessionIndex === -1) {
// Session doesn't exist in sessions array, add it
sessions.push(session);
} else {
// Update existing session
sessions[sessionIndex] = {...session};
}
// Save to storage
saveSessionsToStorage();
saveActiveSession();
// Store the session index for recovery
const index = sessions.findIndex(s => s.id === session.id);
if (index !== -1) {
localStorage.setItem(TEMP_SESSION_INDEX_KEY, index);
}
// Switch to scanner tab
tabs.forEach(t => t.classList.remove('active'));
tabContents.forEach(tc => tc.classList.remove('active'));
document.querySelector('[data-tab="scanner"]').classList.add('active');
document.getElementById('scanner').classList.add('active');
// Update button
startSessionBtn.textContent = 'End Session';
startSessionBtn.removeEventListener('click', startSessionBtnHandler);
startSessionBtn.addEventListener('click', endSessionHandler);
// Start camera
startCamera();
// Start auto-save
startAutoSave();
}
// Save completed sessions to local storage
function saveSessionsToStorage() {
try {
localStorage.setItem(COMPLETED_SESSIONS_STORAGE_KEY, JSON.stringify(sessions));
console.log("Completed sessions saved:", sessions.length);
} catch (error) {
console.error("Error saving completed sessions:", error);
alert("Failed to save sessions. Your device might be low on storage space.");
}
}
// Load sessions from local storage
function loadSessionsFromStorage() {
try {
const savedSessions = localStorage.getItem(COMPLETED_SESSIONS_STORAGE_KEY);
if (savedSessions) {
sessions = JSON.parse(savedSessions);
console.log("Loaded", sessions.length, "completed sessions");
}
} catch (error) {
console.error("Error loading sessions:", error);
sessions = [];
}
}
// Warn user before closing the page during active session
function handleBeforeUnload(event) {
if (activeSession) {
// Save one last time
saveActiveSession();
saveSessionsToStorage();
// Show confirmation dialog
const message = "You have an active scanning session. Are you sure you want to leave?";
event.returnValue = message;
return message;
}
}
//========================================================================================================== HISTORY & DISPLAY FUNCTIONS ========//
// Update history view with sessions
function updateHistoryView() {
if (sessions.length === 0) {
historyList.innerHTML = '<p class="no-results">No scanning sessions found.</p>';
return;
}
// Sort sessions based on selected option
const sortValue = sortBy.value;
const sortedSessions = [...sessions].sort((a, b) => {
if (sortValue === 'date-desc') {
return new Date(b.dateTime) - new Date(a.dateTime);
} else if (sortValue === 'date-asc') {
return new Date(a.dateTime) - new Date(b.dateTime);
} else if (sortValue === 'location') {
return a.location.localeCompare(b.location);
}
return 0;
});
// Generate HTML
historyList.innerHTML = '';
sortedSessions.forEach(session => {
const card = document.createElement('div');
card.className = 'card history-item';
card.setAttribute('data-id', session.id);
// Add class to indicate in-progress sessions
if (session.inProgress) {
card.classList.add('in-progress');
card.style.borderLeft = '4px solid #FF3B58';
}
card.innerHTML = `
<div class="flex-between">
<div>
<h3>${escapeHtml(session.location)}${session.inProgress ? ' <span style="color:#FF3B58">(In Progress)</span>' : ''}</h3>
<p>${session.formattedDateTime}</p>
</div>
<div>
<p><strong>${session.scans.length}</strong> scans</p>
</div>
</div>
`;
card.addEventListener('click', () => {
activeSessionId = session.id;
showSessionDetails(session);
});
historyList.appendChild(card);
});
}
// Show session details
function showSessionDetails(session) {
detailLocation.textContent = session.location;
detailDateTime.textContent = session.formattedDateTime;
detailCount.textContent = session.scans.length;
// Show in-progress status if applicable
const statusElement = document.querySelector('#sessionDetails h3');
if (statusElement) {
if (session.inProgress) {
statusElement.innerHTML = `Session Details <span style="color:#FF3B58">(In Progress)</span>`;
// Add recover button if the session is in progress and not currently active
if (!activeSession || activeSession.id !== session.id) {
const recoverButton = document.createElement('button');
recoverButton.className = 'button';
recoverButton.style.backgroundColor = '#FF3B58';
recoverButton.textContent = 'Resume Session';
recoverButton.addEventListener('click', () => {
recoverSession(session);
sessionDetails.style.display = 'none';  // Hide details after recovering
});
// Insert before export button
const buttonsDiv = document.querySelector('#sessionDetails .buttons');
if (buttonsDiv && buttonsDiv.firstChild) {
buttonsDiv.insertBefore(recoverButton, buttonsDiv.firstChild);
}
}
} else {
statusElement.textContent = 'Session Details';
// Remove recover button if it exists
const recoverButton = document.querySelector('#sessionDetails button[style*="FF3B58"]');
if (recoverButton) {
recoverButton.remove();
}
}
}
// Fill table
detailsBody.innerHTML = '';
session.scans.forEach(scan => {
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
detailsBody.appendChild(row);
});
sessionDetails.style.display = 'block';
}
//========================================================================================================== EXPORT FUNCTIONS ========//
// Export single session to Excel
function exportSession(session) {
if (!window.XLSX) {
console.error("XLSX library not loaded");
alert("Export functionality is not available. Please check your internet connection.");
return;
}
const fileName = `${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Prepare data 
const data = [
['Number', 'Student ID', 'Location', 'Log Date', 'Log Time']
];
session.scans.forEach(scan => {
const scanDate = new Date(scan.time);
data.push([
scan.id,                // Row number (previously ID)
scan.content,           // QR code content is now Student ID
session.location,
formatDate(scanDate),
formatTime(scanDate)
]);
});
// Create workbook
const ws = XLSX.utils.aoa_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Scans");
// First save the file locally
try {
XLSX.writeFile(wb, fileName);
console.log("Excel file saved locally:", fileName);
// After successful local save, then backup to GitHub
setTimeout(() => {
exportExcelToGitHub(fileName, wb)
.then(() => {
console.log("GitHub backup of Excel complete");
})
.catch(err => {
console.error("GitHub backup failed:", err);
});
}, 1000);
} catch (error) {
console.error("Error saving Excel file locally:", error);
alert("Error exporting file: " + error.message);
}
}
// Export all sessions to Excel
function exportAllSessions() {
if (sessions.length === 0) {
alert("No sessions to export");
return;
}
if (!window.XLSX) {
console.error("XLSX library not loaded");
alert("Export functionality is not available. Please check your internet connection.");
return;
}
// First, let's debug what we have
console.log("Attempting to export all sessions:", sessions);
const fileName = `QR_Scan_All_Sessions_${formatDateTimeForFile(new Date())}.xlsx`;
const wb = XLSX.utils.book_new();
// First, create an "AllSessions" sheet with every scan
const allScansData = [
['Number', 'Student ID', 'Location', 'Date', 'Time', 'Session ID']
];
let globalCounter = 1;
// Iterate through each session and add its scans to the master list
sessions.forEach(session => {
if (!session.scans || !Array.isArray(session.scans)) {
console.warn("Session has no valid scans array:", session);
return; // Skip this session
}
session.scans.forEach(scan => {
try {
const scanDate = new Date(scan.time);
allScansData.push([
globalCounter++,
scan.content || "",
session.location || "Unknown",
formatDate(scanDate),
formatTime(scanDate),
session.id || "Unknown"
]);
} catch (error) {
console.error("Error processing scan:", scan, error);
}
});
});
// Create the AllSessions sheet
if (allScansData.length > 1) {
try {
const allScansSheet = XLSX.utils.aoa_to_sheet(allScansData);
XLSX.utils.book_append_sheet(wb, allScansSheet, "AllScans");
} catch (error) {
console.error("Error creating AllScans sheet:", error);
}
}
// Then create individual sheets for each session
sessions.forEach((session, index) => {
try {
if (!session.scans || !Array.isArray(session.scans) || session.scans.length === 0) {
console.warn("Skipping empty session:", session);
return;
}
const sessionData = [
['Number', 'Student ID', 'Location', 'Date', 'Time']
];
session.scans.forEach(scan => {
try {
const scanDate = new Date(scan.time);
sessionData.push([
scan.id || sessionData.length,
scan.content || "",
session.location || "Unknown",
formatDate(scanDate),
formatTime(scanDate)
]);
} catch (error) {
console.error("Error processing scan for session sheet:", scan, error);
}
});
// Create a sheet name from location or use a default
let sheetName = session.location 
? session.location.substring(0, 25).replace(/[^a-z0-9]/gi, '_') 
: "Session";
// Ensure unique sheet name by adding index if needed
sheetName = sheetName.substring(0, 27) + "_" + (index + 1);
// Create and add the sheet
const sessionSheet = XLSX.utils.aoa_to_sheet(sessionData);
XLSX.utils.book_append_sheet(wb, sessionSheet, sheetName);
console.log(`Added sheet for session: ${session.location} with ${session.scans.length} scans`);
} catch (error) {
console.error("Error creating sheet for session:", session, error);
}
});
// Write the file
try {
XLSX.writeFile(wb, fileName);
console.log("All sessions exported successfully to:", fileName);
// Attempt GitHub backup
setTimeout(() => {
try {
exportExcelToGitHub(fileName, wb)
.then(() => console.log("GitHub backup complete"))
.catch(err => console.error("GitHub backup failed:", err));
} catch (e) {
console.error("Error during GitHub backup:", e);
}
// Also trigger a full backup
try {
tryAutoBackup();
} catch (e) {
console.error("Error during auto backup:", e);
}
}, 1000);
} catch (error) {
console.error("Error writing Excel file:", error);
alert("Failed to export sessions: " + error.message);
}
}
//========================================================================================================== HELPER FUNCTIONS ========//
// Add sound effect when QR code is successfully scanned
// Preload the success sound file
function preloadSuccessSound() {
try {
successSound = new Audio('Barcode-scanner-beep-sound.mp3');
// Preload the audio file
successSound.load();
console.log("Success sound preloaded");
} catch (error) {
console.error("Error preloading success sound:", error);
}
}
// Play success sound when QR code is successfully scanned
function playSuccessSound() {
try {
if (successSound) {
// Reset the audio to the beginning if it's already playing
successSound.currentTime = 0;
// Set volume (0.0 to 1.0)
successSound.volume = 0.5;
// Play the sound
successSound.play().catch(error => {
// This catches errors like autoplay being blocked
console.warn("Could not play success sound:", error);
});
} else {
// Fallback if preloading failed
const audio = new Audio('Barcode-scanner-beep-sound.mp3');
audio.volume = 0.5;
audio.play().catch(err => console.warn("Could not play success sound:", err));
}
} catch (error) {
console.error("Error playing success sound:", error);
}
}
// Helper function to format date for display
function formatDate(date) {
return `${date.getFullYear()}-${padZero(date.getMonth() + 1)}-${padZero(date.getDate())}`;
}
// Helper function to format time for display
function formatTime(date) {
return `${padZero(date.getHours())}:${padZero(date.getMinutes())}:${padZero(date.getSeconds())}`;
}
// Helper function to format date and time for display
function formatDateTime(date) {
return `${formatDate(date)} ${formatTime(date)}`;
}
// Helper function to format date and time for filenames
function formatDateTimeForFile(date) {
return `${date.getFullYear()}${padZero(date.getMonth() + 1)}${padZero(date.getDate())}_${padZero(date.getHours())}${padZero(date.getMinutes())}`;
}
// Helper function to pad with leading zero
function padZero(num) {
return num.toString().padStart(2, '0');
}
// Helper function to escape HTML to prevent XSS
function escapeHtml(text) {
if (!text) return '';
return text
.toString()
.replace(/&/g, "&amp;")
.replace(/</g, "&lt;")
.replace(/>/g, "&gt;")
.replace(/"/g, "&quot;")
.replace(/'/g, "&#039;");
}
// Initialize button event handler
startSessionBtn.addEventListener('click', startSessionBtnHandler);
// When window loads, check if we need to request permissions
window.addEventListener('load', () => {
// We request camera permission only when the user starts a session
// instead of on page load for better user experience
// Modern browsers don't allow creating directories or choosing save locations
// for security reasons, but files will be saved according to browser's download settings
});
</script>
</body>
</html>
